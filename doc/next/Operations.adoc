= Operations
:toc: left
:experimental:

All interaction with Site is a series of explicit _actions_.

Operations map onto business functions, such as 'create a customer account' or 'ship a product to a customer'.

An operation are performed on the system.

An _event_ is a record of the successful outcome when an operation is performed.
Events are stored as a log in the database.

When defining an operation, it is possible to specify who is allowed to perform the operation, and in which circumstances.
Operations define their access control in rules, which are sufficient powerful to
model any access control policy (RBAC, ABAC, PBAC, etc.)

////
TODO: Use xrefs from these bullet-points to more detailed explanations, such
that these set of items can become a launchpad for diving into the
documentation.
////

Where necessary, actions run in transaction functions to ensure atomicity and consistency.

Operations can provide involve input validation.

Operations leave an audit trail and may trigger alerts.

Operations can be grouped into OAuth2 scopes.

Operations can be exposed to the network, by being mapped to OpenAPI and/or GraphQL operations.

Operations can cause side-effects (e.g. lambda functions).

Operations decouple network APIs from lower-level effects. For example, an API
implementation can use a 'send-email', without having to know the implementation
details of sending emails.

////
(old text)

A Site instance is a collection of documents, stored in XTDB.

Like XTDB, Site is schemaless and requires that you define your own documents.
However, by included document attributes known to Site (usually in the `juxt.site.alpha` namespace) Site is able to interpret the documents as web or API resources, and serve them over HTTP.

We need to set up sufficient resources in the REPL so that we no longer need to access Site via the REPL.

Secure remote access to Site resources requires an *access token*.

In this section we use the REPL to build up the minimal resources required to acquire an access token which can let us continue setting up the server remotely, without requiring further REPL access.

An access token is granted for a *subject* and an *application*, so we'll need to create those too.

But first, we need to install some preliminary resources into our REPL.
////

== Data consistency

(((data consistency)))
Operations that modify the database are run in a transaction function.

This ensures that the authorization check is made at the latest possible point, just before the database is potentially modified.
This avoids any potential for race-conditions, for example, if the authorization to perform an Operation is revoked just before the Operation is invoked.

== Audit logging

(((audit logging)))
(((do-operation)))
Whenever an Operation is invoked, the `do-operation` transaction function is executed which results in a *transaction metadata record* being created in the database.

This makes it possible to find out when an operation was invoked, by whom, which entities were affected and, potentially, other details such as the 'business justification'.

(((transaction, metadata)))
If the Operation is denied, or if errors occur when the Operation is executed, details will be recorded in the transaction metadata.

This allows us later to answer questions as to whether an Operation was allowed or denied, with an explanation.
We will also be able to answer questions regarding the who, when, why and how for each resource in the database.
A copy of the transaction metadata record is returned as a result of the `do-operation` function, as shown in <<transaction-metadata-record-example>>.

[[transaction-metadata-record-example]]
.A *transaction metadata record*
====

[source,clojure]
----
{:xt/id "https://example.org/_site/event-log/134"
 :xtdb.api/tx-id 134
 :juxt.pass.alpha/subject "https://example.org/_site/subjects/system"
 :juxt.pass.alpha/operation "https://example.org/_site/operations/create-operation"
 :juxt.pass.alpha/purpose nil
 :juxt.pass.alpha/puts ["https://example.org/_site/operations/grant-permission"]
 :juxt.pass.alpha/deletes []}
----
====

== Document structure of an operation

(((operation, document structure)))
<<operation-doc-structure>> lists the attributes commonly found in operation documents.

.Document structure of an Operation
[[operation-doc-structure]]
[%header,cols="2l,1,3d,1"]
|===
|Attribute|Type|Value|Required?

|:xt/id
|String
|Operations are resources, so this is a URI. Callers of actions use this attribute to reference an operation.
s|Required

|:juxt.site.alpha/type
|String
l|"https://meta.juxt.site/pass/operation"
s|Required

|:juxt.site.alpha/description
|String
l|Some text describing what the operation is for.
|Optional

|:juxt.pass.alpha/rules
|Collection
|A collection of Datalog rules that determine whether the operation is allowed.
s|Required

|:juxt.pass.alpha/scope
|String
|A _String_ representing the OAuth 2.0 scope containing the operation.
|Optional

|:juxt.flip.alpha/quotation
|Collection
|A Flip program that performs the operation.
s|Required
|===

== Performing actions with Flip

An operation are performed in a transaction function.
A transaction function must return one or more transaction operations that will be submitted to the database atomically.

Often, actions are required to validate input and construct documents that must be put into the database.

Flip is a bespoke language that is used in transaction functions which is specially designed for the purpose of producing transaction operations.

Flip is a stack-based https://www.concatenative.org/wiki/view/Front%20Page[concatenative] language, drawing heavily from https://factorcode.org/[Factor] and https://www.nsl.com/k/xy/xy.htm[XY].

.Why a dedicated language?
****
The rationale for Flip is that we need a DSL that is constrained so that it is easier to secure.
Another issue with allowing a general purpose language such as Clojure or JavaScript is that we cannot know whether the program will terminate.

The problem with only allowing extensions to be defmethods is that this implies that we need to allow users to add methods to the code-base, and track versions, etc.

The benefit of an internal language is that its primitives can be established earlier on and compositions can be defined in terms of primitives.
Compositions can be added to the database rather than the codebase.
****
