{"version":3,"sources":["shadow/grove/eql_query.cljc"],"mappings":"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","names":["shadow.grove.eql-query/lazy-seq?","thing","cljs.core/LazySeq","cljs.core/realized?","js/shadow","js/shadow.grove","js/shadow.grove.eql-query","js/shadow.grove.eql-query.attr","method-table__5642__auto__","cljs.core.atom","prefer-table__5643__auto__","method-cache__5644__auto__","cached-hierarchy__5645__auto__","hierarchy__5646__auto__","cljs.core.get","fexpr__12462","cljs.core/MultiFn","cljs.core.symbol","shadow.grove.eql-query/attr","env","db","current","query-part","params","shadow.grove.eql-query/process-lookup","result","kw","calced","cljs.core/keyword-identical?","js/goog.DEBUG","cljs.core.ex_info","cljs.core.assoc_BANG_","shadow.grove.eql-query/process-query-part","cljs.core/transient","cljs.core/Keyword","cljs.core/list?","vec__12467","cljs.core.nth","cljs.core/map?","cljs.core._EQ_","cljs.core/count","vec__12472","join-key","join-attrs","cljs.core/first","cljs.core/vector?","join-val","cljs.core.not_EQ_","shadow.grove.db/ident?","val","query-val","shadow.grove.eql_query.query","cljs.core/coll?","cljs.core.mapv","join-item","joined","var_args","G__12509","shadow.grove.eql-query/query","js/Error","query-data","len","i","cljs.core/persistent!"],"sourcesContent":["(ns shadow.grove.eql-query\n  \"minimal EQL query engine\"\n  (:require [shadow.grove.db :as db]))\n\n;; ideally would like to use pathom but currently that carries too much overhead\n;; and is over 10x slower for small simple queries. assuming that a page\n;; has 50 small queries the difference of 0.4ms vs 8.5ms per query is huge\n;; also has quite excessive code size (partly because of spec)\n\n;; pathom of course has a bajillion more features, just need to find a way\n;; to make it more performant for the grove use-cases of many small queries\n;; vs one large query that is composed from the root like fulcro does\n;; I might have just configured or used it wrong\n\n;; as long as everything is EQL it should be fine and easy to switch later\n\n;; unions are currently not supported. not sure where you'd ever need them.\n;; seems like it's only useful if you are forced to build one big query\n;; like in om/fulcro systems which is the first thing I dropped since it felt\n;; way too restrictive to use for me and that concept never \"clicked\".\n\n;; IMHO in the presence of suspense it no longer makes sense to build large queries\n;; since you may want to render parts early when you can\n\n#?(:clj\n   (defn keyword-identical? [x y]\n     (identical? x y)))\n\n(defn lazy-seq? [thing]\n  (and (instance? #?(:clj clojure.lang.LazySeq :cljs cljs.core/LazySeq) thing)\n       (not (realized? thing))))\n\n(declare\n  ^{:arglists '([env db query-data] [env db current query-data])}\n  query)\n\n;; FIXME: shouldn't use a multi-method since DCE doesn't like it\n;; but is the easiest to use with hot-reload in mind\n\n(defmulti attr\n  (fn [env db current query-part params] query-part)\n  :default ::default)\n\n(defmethod attr ::default [env db current query-part params]\n  (get current query-part :db/undefined))\n\n;; kw query with optional params\n;; ::foo\n;; (::foo {:bar 1})\n(defn- process-lookup [env db current result kw params]\n  (let [calced (attr env db current kw params)]\n    (cond\n      (keyword-identical? :db/loading calced)\n      calced\n\n      ;; don't add to result\n      (keyword-identical? :db/undefined calced)\n      result\n\n      :else\n      ;; FIXME: alias support\n      (do #?(:cljs\n             (when ^boolean js/goog.DEBUG\n               (when (lazy-seq? calced)\n                 (throw (ex-info (str \"the lookup of attribute \" kw \" returned a lazy sequence. Attributes must not return lazy sequences. Realize the result before returning (eg. doall).\")\n                          {:kw kw\n                           :result calced})))))\n          (assoc! result kw calced)))))\n\n;; FIXME: this tracking of :db/loading is really annoying, should probably just throw instead?\n(defn- process-query-part\n  [env db current result query-part]\n  (cond\n    (keyword-identical? query-part :db/all)\n    (transient current)\n\n    ;; simple attr\n    (keyword? query-part)\n    (process-lookup env db current result query-part {})\n\n    ;; (::foo {:params 1})\n    (list? query-part)\n    (let [[kw params] query-part]\n      (process-lookup env db current result kw params))\n\n    ;; join\n    ;; {ident [attrs]}\n    ;; {::foo [attrs]}\n    ;; {(::foo {:params 1} [attrs])\n    (map? query-part)\n    (do (when-not (= 1 (count query-part))\n          (throw (ex-info \"join map with more than one entry\" {:query-part query-part})))\n\n        (let [[join-key join-attrs] (first query-part)]\n          (when-not (vector? join-attrs)\n            (throw (ex-info \"join value must be a vector\" {:query-part query-part})))\n\n          (cond\n            (keyword? join-key)\n            (let [join-val (get current join-key ::missing)\n                  join-val\n                  (if (not= ::missing join-val)\n                    join-val\n                    ;; process-lookup but without associng the result since we need to process it\n                    (attr env db current join-key {}))]\n\n              (cond\n                (keyword-identical? join-val :db/loading)\n                join-val\n\n                (keyword-identical? join-val :db/undefined)\n                result\n\n                ;; FIXME: should this return nil or no key at all\n                ;; [{:foo [:bar]}] against {:foo nil}\n                ;; either {} or {:foo nil}?\n                (nil? join-val)\n                result\n\n                ;; {:some-prop [:some-other-ident 123]}\n                ;; FIXME: buggy if val is [:foo :bar] (just a vector of two keywords, no ident)\n                ;; but then the user shouldn't be trying to join so should be fine\n                (db/ident? join-val)\n                (let [val (get db join-val ::missing)]\n                  (cond\n                    (keyword-identical? ::missing val)\n                    (assoc! result join-key ::not-found)\n\n                    (keyword-identical? :db/loading val)\n                    val\n\n                    ;; FIXME: check more possible vals?\n                    :else\n                    (let [query-val (query env db val join-attrs)]\n                      (cond\n                        (keyword-identical? :db/loading query-val)\n                        query-val\n\n                        :else\n                        (assoc! result join-key query-val)))))\n\n                ;; nested-map, may want to join nested\n                (map? join-val)\n                (let [query-val (query env db join-val join-attrs)]\n                  (cond\n                    (keyword-identical? query-val :db/loading)\n                    query-val\n                    :else\n                    (assoc! result join-key query-val)))\n\n                ;; {:some-prop [[:some-other-ident 123] [:some-other-ident 456]]}\n                ;; {:some-prop [{:foo 1} {:foo 2}]}\n                ;; FIXME: should it preserve sets?\n                (coll? join-val)\n                (assoc! result join-key\n                  (mapv\n                    (fn [join-item]\n                      (cond\n                        (db/ident? join-item)\n                        (let [joined (get db join-item)]\n                          (if (map? joined)\n                            (query env db joined join-attrs)\n                            (throw (ex-info \"coll item join missing\" {:join-key join-key\n                                                                      :join-val join-val\n                                                                      :join-item join-item}))))\n\n                        (map? join-item)\n                        (query env db join-item join-attrs)\n\n                        :else\n                        (throw (ex-info \"join-value contained unknown thing\"\n                                 {:join-key join-key\n                                  :join-val join-val\n                                  :join-item join-item\n                                  :current current}))))\n                    join-val))\n\n                :else\n                (throw (ex-info \"don't know how to join\" {:query-part query-part :join-val join-val :join-key join-key}))))\n\n            ;; from root\n            (db/ident? join-key)\n            (let [join-val (get db join-key)]\n              (cond\n                (keyword-identical? :db/loading join-val)\n                join-val\n\n                (nil? join-val)\n                result\n\n                :else\n                (let [query-val (query env db join-val join-attrs)]\n                  (cond\n                    (keyword-identical? :db/loading query-val)\n                    query-val\n                    :else\n                    (assoc! result join-key query-val)))))\n\n            :else\n            (throw (ex-info \"failed to join\" {:query-part query-part\n                                              :current current\n                                              :result result})))))\n\n\n    :else\n    (throw (ex-info \"invalid query part\" {:part query-part}))))\n\n(defn query\n  ([env db query-data]\n   (query env db db query-data))\n  ([env db current query-data]\n   {:pre [(some? env)\n          (map? db)\n          (map? current)\n          (vector? query-data)]}\n   (let [len (count query-data)]\n     (loop [current current\n            result (transient {})\n            i 0]\n       (if (>= i len)\n         (persistent! result)\n         (let [query-part (nth query-data i)\n               result (process-query-part env db current result query-part)]\n           (if (keyword-identical? result :db/loading)\n             result\n             (recur current result (inc i)))))))))\n\n\n(comment\n  (query {}\n    {:hello {:world 1 :foo true}}\n    [{:hello [:world]}]))"]}