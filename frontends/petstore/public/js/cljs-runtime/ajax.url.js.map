{"version":3,"sources":["ajax/url.cljc"],"mappings":";AAwDA,sBAAA,tBAAOA,oDAAYC;AAAnB,AACE,GACE,AAACC,mCAAmBD;AAAK,yDAAA,lDAACE,sDAAa,AAAC,AAACC,6CAAKC,oBAAUC,gBAAML;;AADhE,GAEE,gBAAAM,fAAUN;AAAe,OAACK,eAAKL;;AAFjC,AAG2BA;;;;;AAE7B,AAAeO,wBAEDC;AAEd,iCAAA,yCAAAC,1EAAOG;AAAP,AAAA,IAAAF,aAAAD;QAAA,AAAAE,4CAAAD,WAAA,IAAA,/DAA+BG;QAA/B,AAAAF,4CAAAD,WAAA,IAAA,/DAAiCI;AAAjC,AACO,4EAAA,xBAAK,AAACf,oBAAWc,oDAAO,CAACN,sDAAAA,yDAAAA,LAAaO,qCAAAA;;AAE7C,gCAAA,hCAAOC,wEAAsBC,eAAeH,EAAEC;AAA9C,AAAA,0FACK,CAACE,+CAAAA,kDAAAA,LAAeH,8BAAAA,IAAGC;;AAExB,gCAAA,hCAAOG,wEAAsBC;AAA7B,AACI,IAAMF,iBAAe,iBAAAG,WAAM,iBAAAE,mBAAIH;AAAJ,AAAA,oBAAAG;AAAAA;;AAAA;;;IAANF,eAAA,EAAA,CAAAA,oBAAAb,oBAAA,AAAAa,aAAA;AAAA,AAAA,QAAAA;KAAA;AACY,kBAAKN;AAAL,AAAA;;;;KADZ;AAEa,kBAAKA;AAAL,AAAA;;;;KAFb;AAGeS;;;;AAHf,MAAA,KAAAF,MAAA,CAAA,mEAAAD;;;;AAArB,AAII,OAACI,gDAAQR,8BAAqBC;;AAGtC;;;;;;;oCAAA,qEAAAQ,zGAAOE,gFAMJC,kBAAkBC;AANrB,AAAA,IAAAH,aAAAD;UAAA,AAAAb,4CAAAc,WAAA,IAAA,jEAM6BzB;YAN7B,AAAAW,4CAAAc,WAAA,IAAA,nEAMiCI;AANjC,AAOI,IAAMC,KAAG,AAAC/B,oBAAWC;IACf+B,UAAQ,kBAAIH,QACA,kBAAI5B,KACA,qDAAA,oDAAA,5DAAK4B,wDAAWE,kBAChBF,QACJE;IACZE,UAAQ,AAACT,gDAAQG,kCAAyBC,kBAAkBI;AANlE,AAOI,GACI,OAASF;AADb,0FAAA,mFAEME,QAAQF;;AAFd,GAII,AAAC5B,mCAAmB4B;AAJxB,0FAAA,mFAKME,QAAQ,kDAAA,lDAAC7B,sDAAa,AAAC,AAACC,6CAAKC,oBAAUC,gBAAMwB;;AALnD,GAOI,kBAAAvB,jBAAUuB;AAPd,0FAAA,mFAQME,QAAQ,AAAC1B,eAAKwB;;AARpB,GAUI,AAACI,qBAAKJ;AACN,OAACK,sDAAOF,0DAAQ,AAACG,cAAIN;;AAXzB,GAaI,EAAI,AAACO,4BAAYP,YAAO,AAACQ,qBAAKR;6LACzB,AAACM,cAAIN,pFACL,AAACS,oDAAYX,3KACb,OAACO,sDAAOF;;AAhBjB,AAAA,0FAAA,mFAkBYD,QAAQF;;;;;;;;AAE5B;;;;;;yBAAA,zBAAMU,0DAKHrB,aAAasB;AALhB,mTAMcA,3KACL,8EAAA,KAAA,mFAAA,tKAACd,kCAAyB,AAACT,8BAAqBC,3IAChD,AAACuB,4CAAI7B,zGACL,yDAAA,lDAACV;;AAEV,AAAA;;;8BAAA,sCAAAwC,pEAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC;;;KAAA;AAAA,OAAAA,0DAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAxB,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,4DAAA,5DAAMwB;AAAN,AAEM,iEAAA,1DAACK;;;AAFP,CAAA,4DAAA,WAAAJ,vEAAMD;AAAN,AAAA,IAAAE,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;mBAAA,AAAAE,4CAAAF,eAAA,1EAGY5B;AAHZ,AAAA,kDAAA,uKAAA,qEAAA,pLAIW,AAACgC,yBAAiB,AAAC3B,gDAAQgB,uBAAcrB;;;AAJpD,CAAA,sDAAA,tDAAM0B;;AAAN","names":["ajax.url/key-encode","key","cljs.core/qualified-keyword?","clojure.string.join","cljs.core.juxt","cljs.core/namespace","cljs.core/name","cljs.core/Keyword","ajax.url/value-encode","js/encodeURIComponent","p__22122","vec__22123","cljs.core.nth","ajax.url/key-value-pair-to-str","k","v","ajax.url/vec-key-transform-fn","vec-key-encode","ajax.url/to-vec-key-transform","vec-strategy","G__22128","js/Error","or__5045__auto__","cljs.core/identity","cljs.core.partial","p__22131","vec__22132","ajax.url/param-to-key-value-pairs","vec-key-transform","prefix","value","k1","new-key","recurse","cljs.core/map?","cljs.core.mapcat","cljs.core/seq","cljs.core/sequential?","cljs.core/set?","cljs.core.map_indexed","ajax.url/params-to-str","params","cljs.core.map","var_args","G__22139","ajax.url/url-request-format","p__22140","map__22142","cljs.core/--destructure-map","cljs.core.get","ajax.url.url_request_format","ajax.util/to-utf8-writer"],"sourcesContent":["(ns ajax.url\n\n\"At first blush, it's pretty bizarre that an entire file is devoted to one  \n function, namely params-to-str, which just takes a map and converts it to\n a querystring. However, it turns out that people sometimes want to encode\n fairly complex maps and the behaviour in the presence of vectors/arrays\n is controversial.\n\n The basic question is: what {:a [1 2]} be encoded as? The correct answer\n as far as ring is concerned is a=1&a=2. This is also true of most Java\n implementations, ASP.NET, Angular, Haskell and even old-school ASP. This \n is called vec-strategy :java in the code. Rails and PHP, however, \n prefer a[]=1&a[]=2, which has an obvious implementation in a dynamic \n language. This is called vec-strategy :rails. Finally, there's what \n cljs-ajax (mistakenly) did between versions 0.4.0 and 0.6.x: \n a[0]=1&a[2]=1, which is called vec-strategy :indexed. This is retained \n mostly for people who need to keep compatibility with the previous behaviour.\n\n None of these are the \\\"correct answer\\\": the HTTP standards are\n silent on the subject, so you're left with what your server accepts, and\n different servers have different conventions. Worse, if you send the\n wrong convention it gets misinterpreted. Send strategy :rails to a :java\n server and you get { \\\"a[]\\\" [1 2]}. Worse, send strategy :java to a :rails\n server and you get { \\\"a\\\" 2 }. So it's important to know what your server's\n convention is.\n\n The situation for maps is simpler, pretty much everyone encodes\n {:a {:b 1}} as \\\"a[b]=1\\\". That is, assuming they process it at all.\n The HTTP spec is similarly silent on this and your server may get your\n language's equivalent of { \\\"a[b]\\\" 1 }. In cases like this, you have two\n choices 1) write your own server-side decoder or 2) don't ever send\n nested maps.\n\n If you ever wanted to consider exactly how bad the effect of supporting\n a wide range of use cases, consider that this was the original code:\n\n (defn params-to-str [params]\n    (if params\n        (-> params      \n            clj->js\n            structs/Map.\n            query-data/createFromMap\n            .toString)))\n\n This code remains completely correct for at least 90% of actual users\n of cljs-ajax. Now we have ~50 SLOCs achieving much the same result.\n\"\n\n#? (:clj  (:require\n            [ajax.util :as u]\n            [clojure.string :as str])\n    :cljs (:require\n            [clojure.string :as str]\n            [ajax.util :as u])))\n\n\n(defn- key-encode [key]\n  (cond\n    (qualified-keyword? key) (str/join \"/\" ((juxt namespace name) key))\n    (keyword? key)           (name key)\n    :else                    key))\n\n(def ^:private value-encode ; why doesn't def- exist?\n    #? (:clj (fn value-encode [u] (java.net.URLEncoder/encode (str u) \"UTF-8\"))\n        :cljs js/encodeURIComponent))\n\n(defn- key-value-pair-to-str [[k v]] \n       (str (key-encode k) \"=\" (value-encode v)))\n\n(defn- vec-key-transform-fn [vec-key-encode k v]\n    [(vec-key-encode k) v])\n\n(defn- to-vec-key-transform [vec-strategy]\n    (let [vec-key-encode (case (or vec-strategy :java)\n                               :java (fn [k] nil) ; no subscript\n                               :rails (fn [k] \"\") ; [] subscript\n                               :indexed identity)] ; [1] subscript\n        (partial vec-key-transform-fn vec-key-encode)))\n\n\n(defn- param-to-key-value-pairs \n  \"Takes a parameter and turns it into a sequence of key-value pairs suitable\n     for passing to `key-value-pair-to-str`. Since we can have nested maps and\n     vectors, we need a vec-key-transform function and the current query key\n     prefix as well as the key and value to be analysed. Ultimately, this \n     function walks the structure and flattens it.\"\n  [vec-key-transform prefix [key value]]\n    (let [k1 (key-encode key)\n          new-key (if prefix \n                      (if key \n                          (str prefix \"[\" k1 \"]\")\n                          prefix)\n                      k1)\n          recurse (partial param-to-key-value-pairs vec-key-transform new-key)]\n        (cond \n            (string? value) ; string is sequential so we have to handle it separately\n            [[new-key value]]  ; (\"a\" 1) should be [\"a\" 1]\n\n            (qualified-keyword? value)\n            [[new-key (str/join \"/\" ((juxt namespace name) value))]] ; (:a/b 1) should be [\"a/b\" 1]\n\n            (keyword? value)\n            [[new-key (name value)]] ; (:a 1) should be [\"a\" 1]\n\n            (map? value)\n            (mapcat recurse (seq value)) ; {:b {:a 1}} should be [\"b[a]\" 1]\n\n            (or (sequential? value) (set? value)) ; behaviour depends on vec-key-transform\n            (->> (seq value)\n                 (map-indexed vec-key-transform)\n                 (mapcat recurse))\n\n            :else [[new-key value]])))\n\n(defn params-to-str \n   \"vec-strategy is one of :rails (a[]=3&a[]=4)\n                           :java (a=3&a=4) (this is the correct behaviour and the default)\n                           :indexed (a[3]=1&a[4]=1)\n     params is an arbitrary clojure map\"\n  [vec-strategy params]\n    (->> [nil params]\n         (param-to-key-value-pairs (to-vec-key-transform vec-strategy) nil)\n         (map key-value-pair-to-str)\n         (str/join \"&\")))\n\n(defn url-request-format\n  \"The request format for simple POST and GET.\"\n  ([] (url-request-format {})) \n  ([{:keys [vec-strategy]}]\n   {:write (u/to-utf8-writer (partial params-to-str vec-strategy))\n    :content-type \"application/x-www-form-urlencoded; charset=utf-8\"}))\n"]}