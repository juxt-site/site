{"version":3,"sources":["shadow/grove/impl.cljs"],"mappings":";AAWA,iCAAA,jCAAMA,0EAAcC,EAAEC;AAAtB,AACE,OAAUA,UAAE,WAAKC;AAAL,AAAQ,OAAMF,MAAEE;;;AAE9B,AAEA,AACEC,0CACA,kBAAIC,4BACF,WAAKC;AAAL,AACE,OAACD,2BAA8BC;GACjC,WAAeA;AAAf,AAIE,OAACC,WACC;AAAA,AACE,IAAMC,QAAM,AAACC;oBAAb,mBAAA,nCACMC;AADN,AAGY,QAAA,OAAM,CAAG,AAACD,aAAaD;;AAHnC,AAIE,OAACF,UAAUI;GANjB;;AAUN,AACEC,4CACA,kBAAIC,2BACF,WAAKC;AAAL,AACE,OAACD,0BAA6BC;GAChC,WAAKA;AAAL,AACE,OAACC,aAAgBD;;AAEvB,GAAA,QAAAE,mCAAAC,yCAAAC,8CAAAC;AAAA;AAAA,AAAA,AAASC,gCAAY,KAAAC;;AAErB,GAAA,QAAAL,mCAAAC,yCAAAC,8CAAAI;AAAA;AAAA,AAAA,uCAAA,vCAAkBC;;AAClB,GAAA,QAAAP,mCAAAC,yCAAAC,8CAAAM;AAAA;AAAA,AAAA,iCAAA,jCAASC;;AAET,yCAAA,zCAAMC;AAAN,AACE,GAAMH;AAAN,AACE,oBAAME;AAAN,AACE,AAACb,0CAAmBa;;AACpB,kCAAA,jCAAMA;;AAFR;;AAKA;AAAA,AACE,IAAgBE,aAAK,AAAQP;AAA7B,AACE,GAAeO;AAAf,AACE,AAACA;;AACD;;AAFF;;;;AAIJ,+CAAA,vCAAMJ;;AAZR;;;AAcF,0CAAA,1CAAMK,4FAAsBC;AAA5B,AACE;AAAA,AACE,GAAM,4BAAA,3BAAM,AAAgBA;AAA5B,AACE,IAAgBF,aAAK,AAAQP;AAA7B,AACE,GAAeO;AAAf,AACE,AAACA;;AACD;;AAFF;;AAFJ;;;;AAMF,GAAI,wCAAA,vCAAM,AAASP;AACjB,AAAI,CAAMK,iCAAa,AAACpB,wCAAiBuB;;AACrC,+CAAA,vCAAML;;AACV,AAAI,kCAAA,jCAAME;;AACN,+CAAA,vCAAMF;;;AAEd,2CAAA,3CAAMO;AAAN,AACE,GAAUP;AAAV;;AAAA,AACE,CAAME,iCAAa,AAACpB,wCAAiBuB;;AACrC,+CAAA,vCAAML;;;AAEV,sCAAA,8CAAAQ,pFAAMI,6FAC0EK,SAASC,UAAUC;AADnG,AAAA,IAAAV,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;yBAAA,AAAAE,4CAAAF,eAAA,hFACeI;oBADf,AAAAF,4CAAAF,eAAA,3EACkCK;oBADlC,AAAAH,4CAAAF,eAAA,3EACgDM;sBADhD,AAAAJ,4CAAAF,eAAA,7EAC8DO;AAD9D,AAEE,oBAAM,AAAMH,uBAAmBI;AAA/B,AACE,gBAAA,AAAAG,ZAAMC,4BAAWN;AAAjB,AAGE,AAACO,+CACC,WAAKC,EAAEC;AAAP,AACE,GAAU,AAACC,0BAAUP,UAAUM;AAA/B;AAAA,AACE,IAAME,gBACA,iBAAAC,mBAAI,AAAChB,4CAAIU,UAAUG;AAAnB,AAAA,oBAAAG;AAAAA;;AACI,IAAMC,MAAI,AAACC,mDAAMf,cAAcgB;AAA/B,AACE,AAACD,mDAAMd,cAAcgB,gBAAMP,IAAII;;AAC/BA;;;IAENI,kBACA,iBAAAL,mBAAI,AAAMX,oBAAgBU;AAA1B,AAAA,oBAAAC;AAAAA;;AACI,IAAMK,kBAAU,KAAAC;AAAhB,AACE,AAAMjB,oBAAgBU,cAAQM;;AAC9BA;;;AAVZ,AAYE,AAAMA,oBAAUf;;;AAdtB;GADF,KAkBEE;;AAGF,oBAAMD;AAAN,AACE,OAACI,+CACC,WAAKC,EAAEC;AAAP,AACE,GAAU,AAACC,0BAAUN,UAAUK;AAA/B;;AAAA,AACE,IAAME,UAAQ,AAACf,4CAAIU,UAAUG;IACvBQ,YAAU,AAAMhB,oBAAgBU;AADtC,AAEE,GAAeM;AAAf,AACE,OAASA,iBAAUf;;AADrB;;;GALR,KAQEC;;AATJ;;;AAzBJ;;;AAoCF,gCAAA,hCAAMgB,wEAAaC,IAAIlB,SAASC,UAAUC;AAA1C,AACE,mCAAA,nCAAOtB;AAAP,AAAoB,OAACe,oCAAauB,IAAIlB,SAASC,UAAUC;;;AACzD,OAACZ;;AAKH,wCAAA,gDAAA6B,xFAAME,iGACuDrB,SAASsB;AADtE,AAAA,IAAAF,aAAAD;IAAAC,iBAAA,AAAA3B,4BAAA2B;oBAAA,AAAA1B,4CAAA0B,eAAA,3EACevB;oBADf,AAAAH,4CAAA0B,eAAA,3EAC6BtB;sBAD7B,AAAAJ,4CAAA0B,eAAA,7EAC2CrB;AAD3C,AAME,gBAAA,AAAAI,ZAAMC,4BAAWN;AAAjB,AACE,OAACO,+CACC,WAAKC,EAAEC;AAAP,AACE,IAAME,UACA,iBAAAC,mBAAI,AAAChB,4CAAIU,UAAUG;AAAnB,AAAA,oBAAAG;AAAAA;;AACI,IAAMC,MAAI,AAACC,mDAAMf,cAAcgB;AAA/B,AACE,AAACD,mDAAMd,cAAcgB,gBAAMP,IAAII;;AAC/BA;;;AAJZ,AAME,IAAAY,qBAAsB,AAAMxB,oBAAgBU;AAA5C,AAAA,GAAA,CAAAc,sBAAA;AAAA;;AAAA,gBAAAA,ZAAYR;AAAZ,AACE,OAASA,iBAAUf;;GAT3B,KAWEsB;;AAEN,kCAAA,lCAAME,4EAAeN,IAAIlB,SAASsB;AAAlC,AACE,mCAAA,nCAAO1C;AAAP,AAAoB,OAACyC,sCAAeH,IAAIlB,SAASsB;;;AACjD,OAAChC;;AAEH,0CAAA,kDAAAmC,5FAAME,qGAKHC,SACAC,aACAC;AAPH,AAAA,IAAAJ,aAAAD;IAAAC,iBAAA,AAAAjC,4BAAAiC;UAAAA,NAIwBR;yBAJxB,AAAAxB,4CAAAgC,eAAA,hFAEK9B;sBAFL,AAAAF,4CAAAgC,eAAA,7EAGK3B;oBAHL,AAAAL,4CAAAgC,eAAA,3EAIK5B;AAJL,AAWE,AAACZ;;AAED,IAAM6C,qBAAmB,AAACC,uDAAUJ,SAASE,+DAAaD;gBAA1D,AAAA1B,ZACMC,4BAAWN;IACXmC,YAAU,KAAAjB;AAFhB,AAIE,AAACX,+CACC,WAAKC,EAAEC;AAAP,AAEE,IAAAgB,qBAAmB,AAAC7B,4CAAIU,UAAUG;AAAlC,AAAA,GAAA,CAAAgB,sBAAA;AAAA;;AAAA,aAAAA,TAAYW;AAAZ,AAEE,IAAAX,yBAAsB,AAAMxB,oBAAgBmC;AAA5C,AAAA,GAAA,CAAAX,0BAAA;AAAA;;AAAA,gBAAAA,ZAAYR;AAAZ,AACE,OAACtD,+BAAawE,UAAUlB;;;GANhC,KASEgB;;AAKF,OAAUE,kBACR,WAAKjC;AAAL,AACE,IAAAuB,qBAAkB,AAAM3B,uBAAmBI;AAA3C,AAAA,GAAA,CAAAuB,sBAAA;AAAA;;AAAA,YAAAA,RAAYY;AAAZ,AACE,OAACC,2CAAkBD;;;;AAE7B,iCAAA,jCAAME,0EAAcC,OAAOC,GAAGC;AAA9B,AACE,GACE,WAAA,VAAMA;AACNF;;AAFF,GAIE,GAAK,AAACG,qBAAKD;AACX,MACE,yOAAA,2CAAA,yDAAA,2DAAA,xYAACE,gDACC,CAAA,4FAAqD,AAAA,6EAAIH,gHACjDA,uDACFD,gEACGE;;AAVf,GAYE,CAAY,AAAA,4HAAYF,YAAQ,AAAA,4HAAYE;AAC5CA;;AAbF,AAgBE,MACE,oQAAA,2CAAA,yDAAA,2DAAA,naAACE,gDACC,CAAA,6KAAA,lFAAoD,AAAA,6EAAIH,4IAChDA,uDACFD,gEACGE;;;;;;AAEjB,6CAAA,7CAAMG,kGAAqBC,MAAMC,GAAGC;AAApC,AACE,oBAAI,iBAAAC,oBAAcC;AAAd,AAAA,oBAAAD;AAA4B,OAACN,qBAAKK;;AAAlCC;;;AACF,IAAOE,OAAK,AAACC,sCAAmBJ;IACzBK,UAAQ,CAAA,sEAAA,PAAwBP;;AADvC,AAEE,GAAA,AAAAQ,cAAQH;AAEN,AAAI,AAACI,cAAiBF;;AAClB,MAAO,iIAAA,2CAAA,6DAAA,mDAAA,5RAACT,gDAAQ,CAAA,+DAAwBE,mHAAeA,sDAAUC,4DAAWC;;AAEhF,eACE,AAACQ,mCAAgBL;eACjB,SAAA,RAAKE,6DAAiB,AAACI,2CAAwBN;;;;;;;;AAGrD,MAAO,iIAAA,2CAAA,6DAAA,zOAACP,gDACC,CAAA,+DAAwBE,mHAChBA,sDAAUC;;;AAE/B,kCAAA,iDAAAW,nFAAMG,4EACHC,gBAEAd;AAHH,AAAA,IAAAW,aAAAD;IAAAC,iBAAA,AAAAhE,4BAAAgE;SAAAA,LAEiBlB;YAFjB,AAAA7C,4CAAA+D,eAAA,nEAEIb;AAFJ,AAAA,GAIS,AAACH,qBAAKF;AAJf;AAAA,AAAA,MAAA,KAAAmB,MAAA;;;AAAA,GAKS,kBAAAG,jBAAUjB;AALnB;AAAA,AAAA,MAAA,KAAAc,MAAA;;;AASE,IAAAI,aAAA,AAAA3D,gBAA6DyD;IAA7DE,iBAAA,AAAArE,4BAAAqE;UAAAA,NAAuD5C;eAAvD,AAAAxB,4CAAAoE,eAAA,tEAAkBC;mBAAlB,AAAArE,4CAAAoE,eAAA,1EAA2BE;gBAA3B,AAAAtE,4CAAAoE,eAAA,vEAAwCG;IAClCC,UAAQ,AAACxE,4CAAIsE,aAAapB;AADhC,AAGE,GAAA,AAAAQ,cAAQc;AACN,OAACvB,2CAAoBC,MAAML,GAAGO;;AAE9B,aAAA,AAAA3C,TAAMgE,yBAAQJ;IAERK,QACA,AAACC,2BAAcF;IAEfG,WACA,KAAAC;IAEAC,cACA,6CAAA,7CAACC;IAEDnC,SACA,yDAAA,yJAAA,kFAAA,iCAAA,sDAAA,3XAACoC,qDAAMxD,kGACMoD,8NAEPF,qEAKJ,WAAKO;AAAL,AACE,MAAO,gDAAA,qCAAA,2CAAA,hIAACjC,gLAAkDiC;;IAE9DnC,SACA,AAACH,+BAAaC,OAAOC,GAAG,CAAC2B,wCAAAA,mDAAAA,bAAQ5B,+BAAAA,xBAAOC,+BAAAA;AAxB9C,AA0BE,IAAAqC,aACM,AAACG,6BAAW,AAAA,8EAAKvC;IADvBoC,iBAAA,AAAAnF,4BAAAmF;gBAAAA,ZAA2DE;WAA3D,AAAApF,4CAAAkF,eAAA,lEAAcC;eAAd,AAAAnF,4CAAAkF,eAAA,tEAAmBhD;mBAAnB,AAAAlC,4CAAAkF,eAAA,1EAA4B/C;mBAA5B,AAAAnC,4CAAAkF,eAAA,1EAAyC9C;AAAzC,AAGE,GAAU,CAAA,AAAA3B,gBAAa4D,cAASI;AAAhC;AAAA,AACE,MAAO,gDAAA,4CAAA,5FAACzB;;;AAEV,AAACsC,sBAAOjB,SAASc;;AAGjB,GAAU,CAAYV,WAAOU;AAA7B;AAAA,AACE,AAAClD,wCAAiBT,IAAIU,SAASC,aAAaC;;;AAQ9C,AAACmD,+BACC;AAAA,AACE,IAAAC,aAAA,AAAAC,cAAuB,AAAA,sHAAS3C;IAAhC4C,eAAA;IAAAC,eAAA;IAAAC,WAAA;;AAAA,AAAA,GAAA,AAAA,CAAAA,WAAAD;AAAA,IAAAE,aAAA,AAAAH,kDAAAE;aAAA,AAAAE,4CAAAD,WAAA,IAAA,pEAASW;YAAT,AAAAV,4CAAAD,WAAA,IAAA,nEAAgBY;AAAhB,AAAA,AACE,IAAMC,cAAM,AAAC1G,4CAAIuE,UAAUiC;IAErBG,eACA,qDAAA,rDAAC3B,8CAAMlC,sEAQL;kBAAK8D;AAAL,AACE,oBAAA,AAAAnG,gBAAWqE;AAAX;AAAA,AACE,MAAO,gDAAA,iGAAA,jJAAC9B;;;AAEV,iNAAA,1MAAa,AAAA,qIAA4BxB;;AAAzC,AAA+C,QAACyC,gEAAAA,qFAAAA,vBAAcC,iEAAAA,1DAAO0C,iEAAAA,3DAAMxD,iEAAAA;;CAA3E,mFAAA,uGAAmGoD;;;AAf7G,AAiBE,GAAA,AAAA9C,cAAQgD;AACN,MAAO,6HAAA,2CAAA,gEAAA,xOAAC1D,gDAAQ,CAAA,0DAAmBwD,sHAAiBA,oEAAiBC;;AAErE,CAACC,4CAAAA,gEAAAA,tBAAMC,4CAAAA,/BAAOF,4CAAAA;;;AArBpB;AAAA,eAAAjB;eAAAE;eAAAC;eAAA,CAAAC,WAAA;;;;;;;AAAA,IAAAG,qBAAA,AAAAN,cAAAD;AAAA,AAAA,GAAAO;AAAA,AAAA,IAAAP,iBAAAO;AAAA,AAAA,GAAA,AAAAC,6BAAAR;AAAA,IAAAS,kBAAA,AAAAC,sBAAAV;AAAA,AAAA,eAAA,AAAAW,qBAAAX;eAAAS;eAAA,AAAAG,gBAAAH;eAAA;;;;;;;AAAA,IAAAI,aAAA,AAAAC,gBAAAd;aAAA,AAAAM,4CAAAO,WAAA,IAAA,pEAASG;YAAT,AAAAV,4CAAAO,WAAA,IAAA,nEAAgBI;AAAhB,AAAA,AACE,IAAMC,cAAM,AAAC1G,4CAAIuE,UAAUiC;IAErBG,eACA,qDAAA,rDAAC3B,8CAAMlC,sEAQL;kBAAK8D;AAAL,AACE,oBAAA,AAAAnG,gBAAWqE;AAAX;AAAA,AACE,MAAO,gDAAA,iGAAA,jJAAC9B;;;AAEV,iNAAA,1MAAa,AAAA,qIAA4BxB;;AAAzC,AAA+C,QAACyC,gEAAAA,qFAAAA,vBAAcC,iEAAAA,1DAAO0C,iEAAAA,3DAAMxD,iEAAAA;;CAA3E,mFAAA,uGAAmGoD;;;AAf7G,AAiBE,GAAA,AAAA9C,cAAQgD;AACN,MAAO,6HAAA,2CAAA,gEAAA,xOAAC1D,gDAAQ,CAAA,0DAAmBwD,sHAAiBA,oEAAiBC;;AAErE,CAACC,4CAAAA,gEAAAA,tBAAMC,4CAAAA,/BAAOF,4CAAAA;;;AArBpB;AAAA,eAAA,AAAAF,eAAAf;eAAA;eAAA;eAAA;;;;;;;;AAAA;;;;;;;AAuBJ,IAAA3D,2BAAwB,AAAA,yIAAkBL;AAA1C,AAAA,GAAA,CAAAK,4BAAA;AAAA;AAAA,wBAAAA,pBAAYgF;AAAZ,AAGE,AAACtB,+BACC;AAAA,AACE,aAAA,wCAAA,qEAAA,6DAAA,oDAAA,+DAAA,4DAAA,sDAAA,oEAAA,qEAAA,yDAAA,1lBAAMuB,orBACQjE,TAEGX,7BAEIE,sBAEHqC,TACDU,KACL3D,uBAEL,AAACuF,oBACC,WAAKD,OAAOE,KAAKC;AAAjB,AACE,GAAI,CAAYA,SAAK,AAACjH,4CAAIwB,IAAIwF;AAC5BF;;AACA,OAAC9B,8CAAM8B,OAAOE,KAAKC;;8cAbjB7D,bAEMjB,oBAEV,AAAA,sHAASW,xkBAKb,mCAME,6DAAA,kGAAA,wFAAA,8FAAA,rVAACoE,sDAAOpE;AAjBjB,AAmBE,QAAC+D,kDAAAA,0DAAAA,VAAYC,sCAAAA;;;;AAErB,kCAAA,lCAACxB,sBAAOR;;AAER,OAAA,wFAAShC;;;AAEnB,AAAA;;;;;;;;;;;;;;;;;;;AAAA,AAAA,CAAA,AAAA,sEAAAqE,tEAASK;;AAAT,CAAA,AAAA,6FAAA,7FAASA,wGAcMS,MAAKC;;AAdpB,AAAA,gBAAA,ZAceD;AAdf,AAeI,CAAML,0BAAiBM;;AAEvB,IAAM1G,YAAI,AAAC2G,yCAAqBD;AAAhC,AACE,CAAMhE,gBAAO,AAAA,uIAAkB1C;;AAC/B,CAAMtB,4BAAmB,AAAA,sJAAA,AAAAO,gBAA0ByD;;AAErD,CAAM5D,kBAAS,AAAC8H;;AAEhB,AAAMlI,8BAAmBI,gBAAS2H;;AAElC,OAAWA;;;AAzBf,CAAA,AAAA,+FAAA,/FAAST,0GA2BOS;;AA3BhB,AAAA,gBAAA,ZA2BgBA;AA3BhB,AA4BI,IAAAjH,mBAAI6G;AAAJ,AAAA,oBAAA7G;AAAAA;;AAAW,OAAQ,AAAA,wFAAU2G;;;;AA5BjC,CAAA,AAAA,wFAAA,xFAASH,mGA8BMS;;AA9Bf,AAAA,gBAAA,ZA8BeA;AA9Bf,AA8BqBD;;;AA9BrB,CAAA,AAAA,oGAAA,pGAASR,+GAiCaS,MAAgBI;;AAjCtC,AAAA,gBAAA,ZAiCsBJ;AAjCtB,AAkCI,IAAMK,YAAU,AAASD;IACnBE,qBAAa,AAACC,6CAAEd,aAAMY;AAD5B,AAGE,GAAI,0BAAA,xBAAKC,0BACA,AAACC,6CAAE/F,aAAM,AAAS4F,gBAClB,AAACG,6CAAEb,cAAO,AAAUU;AAF7B;;AAKE,AAAI,GAAUE;AAAV;AAAA,AAME,qBAAA,pBAAMT;;;AAER,CAAMJ,eAAMY;;AACZ,CAAM7F,eAAM,AAAS4F;;AACrB,CAAMV,gBAAO,AAAUU;;AACvB,IAAMI,aAAWT;AAAjB,AACE,AAAWC;;AACX,OAACS,gDAAKD,WAAWT;;;;AAvD/B,CAAA,AAAA,+FAAA,/FAASR,0GA0DQS;;AA1DjB,AAAA,gBAAA,ZA0DiBA;AA1DjB,AA2DI,IAAMQ,aAAWT;AAAjB,AACE,AAAWC;;AACX,OAACS,gDAAKD,WAAWT;;;AA7DvB,CAAA,AAAA,gGAAA,hGAASR,2GA+DSS;;AA/DlB,AAAA,gBAAA,ZA+DkBA;AA/DlB,AAgEI,gCAAA,AAAAxH,hCAACqB,gDAAeoC,eAAO5D,gBAASyH;;AAChC,OAAS7H,iCAAmBI;;;AAjEhC,CAAA,AAAA,uEAAA6G,vEAASK;;AAAT,CAAA,AAAA,kGAAA,lGAASA,6GAoEUS;;AApEnB,AAAA,gBAAA,ZAoEmBA;AApEnB,AAqEI,OAAqBL;;;AArEzB,CAAA,AAAA,sDAAA,tDAASJ;;AAAT,AAAA,YAAA,RAwEaS;AAxEb,AAyEI,sBAAA,AAAAxH,lBAAMkI,kCAAWzE;eAAjB,AAAAzD,XACMmI,2BAAI,AAAA,mIAAeD;AADzB,AAGE,oBAAI,iBAAAtF,oBAAKqE;AAAL,AAAA,oBAAArE;AAAW,wBAAA,hBAAMZ;;AAAjBY;;;AAGF,IAAMP,eAAO,AAAC9C,4CAAI4I,SAAGlB;qBAArB,jBACMmB,gEAAWnB;AADjB,AAIE,GAAM,uBAAA,tBAAOI;AAAb,AACE,AAACvG,8BAAYoH,gBAAUrI,gBAASyH,iBAAUc;;AAD5C;;AAGA,CAAMd,mBAAUc;;AAEhB,GAAI,gDAAA,hDAACC,mCAAmBhG;AACtB,CAAMkF,qBAAY,0LAAA,8FAAA,xRAAChD,8CAAM,AAAA,wGAAA,dAAU2C;;AACnC,AAAI,CAAMK,qBAAYlF;;AAClB,uBAAA,tBAAM+E;;;AAGd,IAAMkB,sBAAc,AAACC,yBAAYJ;IAC3BK,iBAAS,gCAAA,mFAAA,jGAAIvB,iJAAQA,aAAMjF,uBAAQA;IACnCK,eAAO,AAACoG,2DAAUP,gBAAUI,oBAAcE;IAC1CJ,iBAAS,AAAkBE;AAHjC,AAKE,AAACxH,8BAAYoH,gBAAUrI,gBAASyH,iBAAUc;;AAE1C,CAAMd,mBAAUc;;AAEhB,GAAI,gDAAA,hDAACC,mCAAmBhG;AACtB,CAAMkF,qBAAY,0LAAA,8FAAA,xRAAChD,8CAAM,AAAA,wGAAA,dAAU2C;;AAEnC,AAAI,CAAMK,mEACA,kBAAIN,cAAM,AAAC1H,4CAAI8C,aAAO4E,cAAO5E,rJAC7B,mKAAA,8FAAA,jQAACkC;;AACP,uBAAA,tBAAM6C;;;;AAElB,QAAMC,oBAAW,qBAAA,pBAAKA;;;AA/G1B,CAAA,uCAAA,vCAASN;AAAT,AAAA,AAAA;;;AAAA,CAAA,6CAAA,7CAASA;;AAAT,CAAA,gDAAA,hDAASA;;AAAT,CAAA,qDAAA,WAAAJ,mBAAAC,qBAAAC,xGAASE;AAAT,AAAA,OAAAD,iBAAAF,qBAAA;;;AAAA;;;mCAAA,nCAASI,8EACIC,MACAjF,MACAkF,OACYC,iBACZ1D,OACAhE,mBACAI,SACAuH,aACAC,WACAC,UACAC;AAXb,AAAA,YAAAR,4BACaE,MACAjF,MACAkF,OACYC,iBACZ1D,OACAhE,mBACAI,SACAuH,aACAC,WACAC,UACAC;;;AAXJR,AAiHT,+BAAA,/BAAM2B,sEAAYzB,MAAMjF,MAAMkF;AAA9B,AAAA,GACS,EAAI,UAAA,TAAMD,oBAAO,AAAC0B,6BAAU1B;AADrC;AAAA,AAAA,MAAA,KAAA1D,MAAA;;;AAAA,GAES,EAAI,UAAA,TAAMvB,oBAAO,AAAC4G,wBAAQ5G;AAFnC;AAAA,AAAA,MAAA,KAAAuB,MAAA;;;AAAA,GAGS,AAACjB,qBAAK4E;AAHf;AAAA,AAAA,MAAA,KAAA3D,MAAA;;;AAIE,YAAAwD,+CAAA,KAAA,KAAA,KAAA,KAAA,MAAA,IAAA,KAAA,tDACEE,MACAjF,MACAkF;;AAUJ,AAAA;;;;;;;;;;;;;;AAAA,AAAA,CAAA,AAAA,yEAAAR,zEAASmC;;AAAT,CAAA,AAAA,oGAAA,pGAASA,+GAUUrB;;AAVnB,AAAA,gBAAA,ZAUmBA;AAVnB,AAWI,oBAAUwB;AAAV;;AAAA,AACE,OAAWxB;;;;AAZjB,CAAA,AAAA,wDAAA,xDAASqB;;AAAT,AAAA,YAAA,RAearB;AAfb,AAgBI,gBAAA,AAAAxH,ZAAMkI,4BAAWzE;IACX6E,gBAAc,yBAAA,AAAAtI,zBAACuI,yCAAa,AAAA,mIAAeL;IAC3C7F,SAAO,AAACoG,2DAAUP,UAAUI,cAActG;IAC1CoG,WAAS,AAAkBE;AAHjC,AAME,AAACxH,8BAAYoH,UAAUrI,gBAASyH,iBAAUc;;AAE1C,CAAMd,mBAAUc;;AAGhB,GAAM,qHAAA,6BAAA,hJAAK,GAAK,0CAAA,1CAACC,mCAAmBhG,+EAIzB,GAAA,WAAA,VAAOA,yBACP,GAAK,AAAC4G,uBAAO5G,eAEb,AAAC4F,gDAAK5F,OAAOkF;AAPxB,AASE,CAAMA,qBAAYlF;;AAElB,QAAC0G,gDAAAA,wDAAAA,VAAS1G,oCAAAA;;AAXZ;;;;AA3BN,CAAA,AAAA,wDAAA,xDAASwG;;AAAT,AAAA,YAAA,RAwCarB;AAxCb,AAyCI,2BAAA,1BAAMwB;;AACN,uCAAA,AAAAhJ,hCAACqB,gDAAeoC,eAAO5D,gBAASyH;;;AA1CpC,CAAA,yCAAA,zCAASuB;AAAT,AAAA,AAAA;;;AAAA,CAAA,+CAAA,/CAASA;;AAAT,CAAA,kDAAA,lDAASA;;AAAT,CAAA,uDAAA,WAAAlC,mBAAAC,qBAAAC,1GAASgC;AAAT,AAAA,OAAA/B,iBAAAF,qBAAA;;;AAAA;;;qCAAA,rCAASkC,kFACNrF,OACA5D,SACAmC,MACA+G,SACUzB,UACAC,YACAyB;AAPb,AAAA,YAAAH,8BACGpF,OACA5D,SACAmC,MACA+G,SACUzB,UACAC,YACAyB;;;AAPJH,AA6CT,+BAAA,/BAAMK,sEAAYzF,OAAO5D,SAASmC,MAAMkF,OAAO6B;AAA/C,AACE,IAAAI,aAAA,AAAAnJ,gBAAwCyD;IAAxC0F,iBAAA,AAAA7J,4BAAA6J;yBAAA,AAAA5J,4CAAA4J,eAAA,hFAAkB1J;IACZ2J,IAAE,KAAAP,6DAAA,KAAA,KAAA,zCAAcpF,OAAO5D,SAASmC,MAAM+G;AAD5C,AAEE,AAAMtJ,uBAAmBI,SAASuJ;;AAClC,OAAWA;;AAEf,kCAAA,lCAAMC,4EAAe5F,OAAO5D;AAA5B,AACE,IAAAyJ,aAAA,AAAAtJ,gBAAwCyD;IAAxC6F,iBAAA,AAAAhK,4BAAAgK;yBAAA,AAAA/J,4CAAA+J,eAAA,hFAAkB7J;AAAlB,AACE,IAAA2B,qBAAc,AAAM3B,uBAAmBI;AAAvC,AAAA,GAAA,CAAAuB,sBAAA;AAAA;;AAAA,QAAAA,JAAYgI;AAAZ,AACE,AAAS3J,0BAAmBI;;AAC5B,OAAWuJ","names":["shadow.grove.impl/js-set-union","a","b","x","shadow.grove.impl/work-queue-task!","js/window.requestIdleCallback","work-task","js/setTimeout","start","js/Date.now","fake-deadline","shadow.grove.impl/work-queue-cancel!","js/window.cancelIdleCallback","id","js/clearTimeout","js/shadow","js/shadow.grove","js/shadow.grove.impl","js/shadow.grove.impl.index-queue","shadow.grove.impl/index-queue","js/Array","js/shadow.grove.impl.work-queued?","shadow.grove.impl/work-queued?","js/shadow.grove.impl.work-timeout","shadow.grove.impl/work-timeout","shadow.grove.impl/index-work-all!","task","shadow.grove.impl/index-work-some!","deadline","shadow.grove.impl/index-queue-some!","p__12602","map__12603","cljs.core/--destructure-map","cljs.core.get","shadow.grove.impl/index-query*","active-queries-map","key-index-seq","key-index-ref","query-index-map","query-id","prev-keys","next-keys","cljs.core/deref","key-index","cljs.core.reduce","_","key","cljs.core/contains?","key-idx","or__5045__auto__","idx","cljs.core.swap_BANG_","cljs.core/inc","cljs.core/assoc","query-set","js/Set","shadow.grove.impl/index-query","env","p__12605","map__12606","shadow.grove.impl/unindex-query*","keys","temp__5808__auto__","shadow.grove.impl/unindex-query","p__12608","map__12609","shadow.grove.impl/invalidate-keys!","keys-new","keys-removed","keys-updated","keys-to-invalidate","clojure.set.union","query-ids","key-id","query","shadow.grove.protocols/query-refresh!","shadow.grove.impl/merge-result","tx-env","ev","result","cljs.core/map?","cljs.core.ex_info","shadow.grove.impl/unhandled-event-ex!","ev-id","tx","origin","and__5043__auto__","js/goog.DEBUG","comp","shadow.grove.components/get-component","err-msg","cljs.core/not","js/console.error","shadow.grove.components/get-parent","shadow.grove.components/get-component-name","p__12631","map__12632","js/Error","shadow.grove.impl/process-event","rt-ref","cljs.core/Keyword","map__12661","data-ref","event-config","fx-config","handler","before","tx-db","shadow.grove.db/transacted","tx-guard","js/Object","tx-done-ref","cljs.core.atom","cljs.core.assoc","next-tx","map__12663","data","tx-result","shadow.grove.db/commit!","cljs.core/reset!","shadow.grove.runtime/next-tick","seq__12667","cljs.core/seq","chunk__12668","count__12669","i__12670","vec__12712","cljs.core.nth","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","vec__12720","cljs.core/first","cljs.core/next","fx-key","value","fx-fn","fx-env","fx-tx","tx-reporter","report","cljs.core/reduce-kv","rkey","rval","cljs.core.dissoc","cljs.core/PROTOCOL_SENTINEL","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","shadow.grove.impl/HookQuery","shadow.grove.impl/->HookQuery","ident","config","component-handle","ready?","read-count","read-keys","read-result","this","ch","shadow.grove.protocols/get-component-env","shadow.grove.runtime/next-id","val","new-ident","ident-equal?","cljs.core._EQ_","old-result","cljs.core.not_EQ_","query-env","db","new-keys","cljs.core/keyword-identical?","observed-data","shadow.grove.db/observed","db-query","shadow.grove.eql_query.query","shadow.grove.impl/hook-query","shadow.grove.db/ident?","cljs.core/vector?","shadow.grove.impl/DirectQuery","shadow.grove.impl/->DirectQuery","callback","destroyed?","cljs.core/empty?","shadow.grove.impl/query-init","map__12765","q","shadow.grove.impl/query-destroy","map__12771"],"sourcesContent":["(ns shadow.grove.impl\n  (:require\n    [clojure.set :as set]\n    [shadow.grove :as-alias sg]\n    [shadow.grove.protocols :as gp]\n    [shadow.grove.runtime :as rt]\n    [shadow.grove.db :as db]\n    [shadow.grove.eql-query :as eql]\n    [shadow.grove.components :as comp]\n    ))\n\n(defn js-set-union [a b]\n  (.forEach b (fn [x] (.add a x))))\n\n(set! *warn-on-infer* false)\n\n(def ^function\n  work-queue-task!\n  (if js/window.requestIdleCallback\n    (fn [work-task]\n      (js/window.requestIdleCallback work-task))\n    (fn [^function work-task]\n      ;; microtask or goog.async.run don't do what we want\n      ;; we want the browser to prioritise rendering stuff\n      ;; the other work can be delayed until idle. setTimeout seems closest.\n      (js/setTimeout\n        (fn []\n          (let [start (js/Date.now)\n                fake-deadline\n                #js {:timeRemaining\n                     #(< 16 (- (js/Date.now) start))}]\n            (work-task fake-deadline)))\n        ;; usually 4 or so minimum but that is good enough for our purposes\n        0))))\n\n(def ^function\n  work-queue-cancel!\n  (if js/window.cancelIdleCallback\n    (fn [id]\n      (js/window.cancelIdleCallback id))\n    (fn [id]\n      (js/clearTimeout id))))\n\n(defonce index-queue (js/Array.))\n\n(defonce ^boolean work-queued? false)\n(defonce work-timeout nil)\n\n(defn index-work-all! []\n  (when work-queued?\n    (when work-timeout\n      (work-queue-cancel! work-timeout)\n      (set! work-timeout nil))\n\n    ;; work until all work is done, immediately work off new tasks\n    (loop []\n      (let [^function task (.shift index-queue)]\n        (when ^boolean task\n          (task)\n          (recur))))\n\n    (set! work-queued? false)))\n\n(defn index-work-some! [^js deadline]\n  (loop []\n    (when (pos? (.timeRemaining deadline))\n      (let [^function task (.shift index-queue)]\n        (when ^boolean task\n          (task)\n          (recur)))))\n\n  (if (pos? (alength index-queue))\n    (do (set! work-timeout (work-queue-task! index-work-some!))\n        (set! work-queued? true))\n    (do (set! work-timeout nil)\n        (set! work-queued? false))))\n\n(defn index-queue-some! []\n  (when-not work-queued?\n    (set! work-timeout (work-queue-task! index-work-some!))\n    (set! work-queued? true)))\n\n(defn index-query*\n  [{::rt/keys [active-queries-map key-index-seq key-index-ref query-index-map]} query-id prev-keys next-keys]\n  (when (.has active-queries-map query-id)\n    (let [key-index @key-index-ref]\n\n      ;; index keys that weren't used previously\n      (reduce\n        (fn [_ key]\n          (when-not (contains? prev-keys key)\n            (let [key-idx\n                  (or (get key-index key)\n                      (let [idx (swap! key-index-seq inc)]\n                        (swap! key-index-ref assoc key idx)\n                        idx))\n\n                  query-set\n                  (or (.get query-index-map key-idx)\n                      (let [query-set (js/Set.)]\n                        (.set query-index-map key-idx query-set)\n                        query-set))]\n\n              (.add query-set query-id)))\n          nil)\n        nil\n        next-keys)\n\n      ;; remove old keys that are no longer used\n      (when prev-keys\n        (reduce\n          (fn [_ key]\n            (when-not (contains? next-keys key)\n              (let [key-idx (get key-index key)\n                    query-set (.get query-index-map key-idx)]\n                (when ^boolean query-set\n                  (.delete query-set query-id)))))\n          nil\n          prev-keys)))))\n\n(defn index-query [env query-id prev-keys next-keys]\n  (.push index-queue #(index-query* env query-id prev-keys next-keys))\n  (index-queue-some!))\n\n;; FIXME: this needs some kind of GC\n;; currently does not remove empty sets from query-index-map\n\n(defn unindex-query*\n  [{::rt/keys [key-index-seq key-index-ref query-index-map]} query-id keys]\n\n  ;; FIXME: does this need to check if query is still active?\n  ;; I don't think so because unindex is called on destroy and things are never destroyed twice\n\n  (let [key-index @key-index-ref]\n    (reduce\n      (fn [_ key]\n        (let [key-idx\n              (or (get key-index key)\n                  (let [idx (swap! key-index-seq inc)]\n                    (swap! key-index-ref assoc key idx)\n                    idx))]\n\n          (when-some [query-set (.get query-index-map key-idx)]\n            (.delete query-set query-id))))\n      nil\n      keys)))\n\n(defn unindex-query [env query-id keys]\n  (.push index-queue #(unindex-query* env query-id keys))\n  (index-queue-some!))\n\n(defn invalidate-keys!\n  [{::rt/keys\n    [active-queries-map\n     query-index-map\n     key-index-ref] :as env}\n   keys-new\n   keys-removed\n   keys-updated]\n\n  ;; before we can invalidate anything we need to make sure the index is updated\n  ;; we delay updating index stuff to be async since we only need it here later\n  (index-work-all!)\n\n  (let [keys-to-invalidate (set/union keys-new keys-updated keys-removed)\n        key-index @key-index-ref\n        query-ids (js/Set.)]\n\n    (reduce\n      (fn [_ key]\n        ;; key might not be used by any query so might not have an id\n        (when-some [key-id (get key-index key)]\n          ;; same here\n          (when-some [query-set (.get query-index-map key-id)]\n            (js-set-union query-ids query-set))))\n\n      nil\n      keys-to-invalidate)\n\n    ;; just refreshes all affected queries in no deterministic order\n    ;; each query will figure out on its own if if actually triggers an update\n    ;; FIXME: figure out if this can be smarter\n    (.forEach query-ids\n      (fn [query-id]\n        (when-some [query (.get active-queries-map query-id)]\n          (gp/query-refresh! query))))))\n\n(defn merge-result [tx-env ev result]\n  (cond\n    (nil? result)\n    tx-env\n\n    (not (map? result))\n    (throw\n      (ex-info\n        (str \"tx handler returned invalid result for event \" (:e ev))\n        {:event ev\n         :env tx-env\n         :result result}))\n\n    (identical? (::tx-guard tx-env) (::tx-guard result))\n    result\n\n    :else\n    (throw\n      (ex-info\n        (str \"tx handler returned invalid result for event\" (:e ev) \", expected a modified env\")\n        {:event ev\n         :env tx-env\n         :result result}))))\n\n(defn unhandled-event-ex! [ev-id tx origin]\n  (if (and ^boolean js/goog.DEBUG (map? origin))\n    (loop [comp (comp/get-component origin)\n           err-msg (str \"Unhandled Event \" ev-id \"\\n    Component Trace:\")]\n      (if-not comp\n        ;; FIXME: directly outputting this is here is kinda ugly?\n        (do (js/console.error err-msg)\n            (throw (ex-info (str \"Unhandled Event \" ev-id) {:ev-id ev-id :tx tx :origin origin})))\n\n        (recur\n          (comp/get-parent comp)\n          (str err-msg \"\\n    \" (comp/get-component-name comp))\n          )))\n\n    (throw (ex-info\n             (str \"Unhandled Event \" ev-id)\n             {:ev-id ev-id :tx tx}))))\n\n(defn process-event\n  [rt-ref\n   {ev-id :e :as ev}\n   origin]\n  {:pre [(map? ev)\n         (keyword? ev-id)]}\n\n  ;; (js/console.log ev-id ev origin @rt-ref)\n\n  (let [{::rt/keys [data-ref event-config fx-config] :as env} @rt-ref\n        handler (get event-config ev-id)]\n\n    (if-not handler\n      (unhandled-event-ex! ev-id ev origin)\n\n      (let [before @data-ref\n\n            tx-db\n            (db/transacted before)\n\n            tx-guard\n            (js/Object.)\n\n            tx-done-ref\n            (atom false)\n\n            tx-env\n            (assoc env\n              ::tx-guard tx-guard\n              ::fx []\n              :db tx-db\n              ;; FIXME: should this be strict and only allow chaining tx from fx handlers?\n              ;; should be forbidden to execute side effects directly in tx handlers?\n              ;; but how do we enforce this cleanly? this feels kinda dirty maybe needless indirection?\n              :transact!\n              (fn [next-tx]\n                (throw (ex-info \"transact! only allowed from fx env\" {:tx next-tx}))))\n\n            result\n            (merge-result tx-env ev (handler tx-env ev))]\n\n        (let [{:keys [data keys-new keys-removed keys-updated] :as tx-result}\n              (db/commit! (:db result))]\n\n          (when-not (identical? @data-ref before)\n            (throw (ex-info \"someone messed with app-state while in tx\" {})))\n\n          (reset! data-ref data)\n\n          ;; FIXME: figure out if invalidation/refresh should be immediate or microtask'd/delayed?\n          (when-not (identical? before data)\n            (invalidate-keys! env keys-new keys-removed keys-updated))\n\n          ;; FIXME: re-frame allows fx to edit db but we already committed it\n          ;; currently not checking fx-fn return value at all since they supposed to run side effects only\n          ;; and may still edit stuff in env, just not db?\n\n          ;; dispatching async so render can get to it sooner\n          ;; dispatching these async since they can never do anything that affects the current render right?\n          (rt/next-tick\n            (fn []\n              (doseq [[fx-key value] (::rt/fx result)]\n                (let [fx-fn (get fx-config fx-key)\n\n                      fx-env\n                      (assoc result\n                        ;; creating this here so we can easily track which fx caused further work\n                        ;; technically all fx could run-now! directly given they have the scheduler from the env\n                        ;; but here we can easily track tx-done-ref to ensure fx doesn't actually immediately trigger\n                        ;; other events when they shouldn't because this is still in run-now! itself\n                        ;; FIXME: remove this once this is handled directly in the scheduler\n                        ;; run-now! inside run-now! should be a hard error\n                        :transact!\n                        (fn [fx-tx]\n                          (when-not @tx-done-ref\n                            (throw (ex-info \"cannot start another tx yet, current one is still running. transact! is meant for async events\" {})))\n\n                          (gp/run-now! ^not-native (::rt/scheduler env) #(process-event rt-ref fx-tx origin) [::fx-transact! fx-key])))]\n\n                  (if-not fx-fn\n                    (throw (ex-info (str \"unknown fx \" fx-key) {:fx-key fx-key :fx-value value}))\n\n                    (fx-fn fx-env value))))))\n\n          (when-some [tx-reporter (::rt/tx-reporter env)]\n            ;; dispatch tx-reporter async so it doesn't hold up rendering\n            ;; the only purpose of this is debugging anyways\n            (rt/next-tick\n              (fn []\n                (let [report\n                      {:event ev\n                       :origin origin\n                       :keys-new keys-new\n                       :keys-removed keys-removed\n                       :keys-updated keys-updated\n                       :fx (::rt/fx result)\n                       :db-before before\n                       :db-after data\n                       :env env\n                       :env-changes\n                       (reduce-kv\n                         (fn [report rkey rval]\n                           (if (identical? rval (get env rkey))\n                             report\n                             (assoc report rkey rval)))\n                         {}\n                         (dissoc result :db ::rt/fx ::tx-guard :transact!))}]\n\n                  (tx-reporter report)))))\n\n          (reset! tx-done-ref true)\n\n          (:return result))))))\n\n(deftype HookQuery\n  [^:mutable ident\n   ^:mutable query\n   ^:mutable config\n   ^:mutable ^not-native component-handle\n   ^:mutable rt-ref\n   ^:mutable active-queries-map\n   ^:mutable query-id\n   ^:mutable ready?\n   ^:mutable read-count\n   ^:mutable read-keys\n   ^:mutable read-result]\n\n  gp/IHook\n  (hook-init! [this ch]\n    (set! component-handle ch)\n\n    (let [env (gp/get-component-env ch)]\n      (set! rt-ref (::rt/runtime-ref env))\n      (set! active-queries-map (::rt/active-queries-map @rt-ref)))\n\n    (set! query-id (rt/next-id))\n\n    (.set active-queries-map query-id this)\n\n    (.do-read! this))\n\n  (hook-ready? [this]\n    (or ready? (false? (:suspend config))))\n\n  (hook-value [this] read-result)\n\n  ;; node deps changed, check if query changed\n  (hook-deps-update! [this ^HookQuery val]\n    (let [new-ident (.-ident val)\n          ident-equal? (= ident new-ident)]\n\n      (if (and ident-equal?\n               (= query (.-query val))\n               (= config (.-config val)))\n        false\n        ;; query changed, perform read immediately\n        (do (when-not ident-equal?\n              ;; need to reset this to 0 since do-read! uses this to track\n              ;; whether it needs to index the query or not\n              ;; thus a query with changing ident is not properly re-indexed if this is not reset\n              ;; I intended read-count as a debug utility to find overly active queries\n              ;; so this somehow needs to be addressed properly somewhere so this doesn't have multiple uses\n              (set! read-count 0))\n\n            (set! ident new-ident)\n            (set! query (.-query val))\n            (set! config (.-config val))\n            (let [old-result read-result]\n              (.do-read! this)\n              (not= old-result read-result))))))\n\n  ;; node was invalidated and needs update\n  (hook-update! [this]\n    (let [old-result read-result]\n      (.do-read! this)\n      (not= old-result read-result)))\n\n  (hook-destroy! [this]\n    (unindex-query @rt-ref query-id read-keys)\n    (.delete active-queries-map query-id))\n\n  gp/IQuery\n  (query-refresh! [this]\n    (gp/hook-invalidate! component-handle))\n\n  Object\n  (do-read! [this]\n    (let [query-env @rt-ref\n          db @(::rt/data-ref query-env)]\n\n      (if (and ident (nil? query))\n        ;; shortcut for just getting data for an ident\n        ;; don't need all the query stuff for those\n        (let [result (get db ident)\n              new-keys #{ident}]\n\n          ;; only need to index once\n          (when (zero? read-count)\n            (index-query query-env query-id read-keys new-keys))\n\n          (set! read-keys new-keys)\n\n          (if (keyword-identical? result :db/loading)\n            (set! read-result (assoc (:default config {}) ::sg/loading-state :loading))\n            (do (set! read-result result)\n                (set! ready? true))))\n\n        ;; query env is not the component env\n        (let [observed-data (db/observed db)\n              db-query (if ident [{ident query}] query)\n              result (eql/query query-env observed-data db-query)\n              new-keys (db/observed-keys observed-data)]\n\n          (index-query query-env query-id read-keys new-keys)\n\n          (set! read-keys new-keys)\n\n          (if (keyword-identical? result :db/loading)\n            (set! read-result (assoc (:default config {}) ::sg/loading-state :loading))\n\n            (do (set! read-result\n                  (-> (if ident (get result ident) result)\n                      (assoc ::sg/loading-state :ready)))\n                (set! ready? true))))))\n\n    (set! read-count (inc read-count))))\n\n(defn hook-query [ident query config]\n  {:pre [(or (nil? ident) (db/ident? ident))\n         (or (nil? query) (vector? query))\n         (map? config)]}\n  (HookQuery.\n    ident\n    query\n    config\n    nil\n    nil\n    nil\n    nil\n    false\n    0\n    nil\n    nil))\n\n(deftype DirectQuery\n  [rt-ref\n   query-id\n   query\n   callback\n   ^:mutable read-keys\n   ^:mutable read-result\n   ^:mutable destroyed?]\n\n  gp/IQuery\n  (query-refresh! [this]\n    (when-not destroyed?\n      (.do-read! this)))\n\n  Object\n  (do-read! [this]\n    (let [query-env @rt-ref\n          observed-data (db/observed @(::rt/data-ref query-env))\n          result (eql/query query-env observed-data query)\n          new-keys (db/observed-keys observed-data)]\n\n      ;; remember this even if query is still loading\n      (index-query query-env query-id read-keys new-keys)\n\n      (set! read-keys new-keys)\n\n      ;; if query is still loading don't send to main\n      (when (and (not (keyword-identical? result :db/loading))\n                 ;; empty result likely means the query is no longer valid\n                 ;; eg. deleted ident. don't send update, will likely be destroyed\n                 ;; when other query updates\n                 (some? result)\n                 (not (empty? result))\n                 ;; compare here so main doesn't need to compare again\n                 (not= result read-result))\n\n        (set! read-result result)\n\n        (callback result))))\n\n  (destroy! [this]\n    (set! destroyed? true)\n    (unindex-query @rt-ref query-id read-keys)))\n\n;; direct query, hooks don't use this\n(defn query-init [rt-ref query-id query config callback]\n  (let [{::rt/keys [active-queries-map]} @rt-ref\n        q (DirectQuery. rt-ref query-id query callback nil nil false)]\n    (.set active-queries-map query-id q)\n    (.do-read! q)))\n\n(defn query-destroy [rt-ref query-id]\n  (let [{::rt/keys [active-queries-map]} @rt-ref]\n    (when-some [q (.get active-queries-map query-id)]\n      (.delete active-queries-map query-id)\n      (.destroy! q))))"]}