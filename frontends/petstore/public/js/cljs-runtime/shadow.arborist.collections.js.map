{"version":3,"sources":["shadow/arborist/collections.cljs"],"mappings":"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","names":["this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","shadow.arborist.collections/KeyedItem","shadow.arborist.collections/->KeyedItem","key","data","managed","moved?","cljs.core/PROTOCOL_SENTINEL","shadow.arborist.collections/KeyedCollection","shadow.arborist.collections/->KeyedCollection","env","coll","key-fn","render-fn","items","item-keys","marker-before","marker-after","dom-entered?","this","parent","anchor","item","next","shadow.arborist.collections/KeyedCollectionInit","old-coll","new-coll","dom-parent","rfn-identical?","cljs.core.ex_info","kfn","shadow.arborist.common/ifn1-wrap","rfn","shadow.arborist.common/ifn3-wrap","new-len","old-items","new-items","js/Array","new-keys","cljs.core/-persistent!","cljs.core/reduce-kv","keys","idx","val","cljs.core/-as-transient","cljs.core.not_EQ_","cljs.core/contains?","old-idx","new-item","old-item","cljs.core.get","cljs.core/not","rendered","shadow.arborist.protocols/as-managed","new-managed","seek-idx","item-at-idx","dom-remove?","G__11600","js/document.createRange","shadow.arborist.collections/->KeyedCollectionInit","len","cljs.core/count","shadow.arborist.common.dom_marker","cljs.core/persistent!","cljs.core.assoc_BANG_","cljs.core/transient","other","cljs.core/keyword-identical?","cljs.core._EQ_","js/Error","shadow.arborist.collections/keyed-seq","cljs.core/sequential?","cljs.core/ifn?","cljs.core/vec","shadow.arborist.collections/SimpleItem","shadow.arborist.collections/->SimpleItem","shadow.arborist.collections/SimpleCollection","shadow.arborist.collections/->SimpleCollection","shadow.arborist.collections/SimpleCollectionInit","oc","nc","max-idx","js/Math.min","shadow.arborist.common/ifn2-wrap","n__5636__auto__","new-data","new-rendered","shadow.arborist.common/replace-managed","shadow.arborist.protocols/dom-entered!","shadow.arborist.protocols/dom-insert","G__11651","shadow.arborist.collections/->SimpleCollectionInit","arr","_","shadow.arborist.collections/simple-seq"],"sourcesContent":["(ns shadow.arborist.collections\n  (:require\n    [shadow.arborist.protocols :as p]\n    [shadow.arborist.common :as common]))\n\n(declare KeyedCollectionInit)\n\n(deftype KeyedItem [key data managed moved?])\n\n(deftype KeyedCollection\n  [env\n   ^:mutable coll\n   ^:mutable ^function key-fn\n   ^:mutable ^function render-fn\n   ^:mutable items ;; array of KeyedItem instances\n   ^:mutable item-keys ;; map of key -> items index\n   marker-before\n   marker-after\n   ^boolean ^:mutable dom-entered?]\n\n  p/IManaged\n  (dom-first [this] marker-before)\n\n  (dom-insert [this parent anchor]\n    (.insertBefore parent marker-before anchor)\n    (.forEach items\n      (fn [^KeyedItem item]\n        (p/dom-insert ^not-native (.-managed item) parent anchor)))\n    (.insertBefore parent marker-after anchor))\n\n  (dom-entered! [this]\n    (set! dom-entered? true)\n    (.forEach items\n      (fn [^KeyedItem item]\n        (p/dom-entered! ^not-native (.-managed item)))))\n\n  (supports? [this next]\n    (instance? KeyedCollectionInit next))\n\n  (dom-sync! [this ^KeyedCollectionInit next]\n    (let [^not-native old-coll coll\n          ^not-native new-coll (.-coll next)\n          dom-parent (.-parentNode marker-after)\n          rfn-identical? (identical? render-fn (.-render-fn next))]\n\n      (when-not ^boolean dom-parent\n        (throw (ex-info \"sync while not in dom?\" {})))\n\n      (when-not (and rfn-identical? (identical? old-coll new-coll))\n\n        (set! coll new-coll)\n        (set! key-fn (.-key-fn next))\n        (set! render-fn (.-render-fn next))\n\n        (let [^function kfn (common/ifn1-wrap key-fn)\n              ^function rfn (common/ifn3-wrap render-fn)\n\n              new-len (-count new-coll)\n\n              ;; array of KeyedItem with manage instances\n              old-items items\n              ;; array of KeyedItem but managed will be set later\n              new-items (js/Array. new-len)\n\n              ;; traverse new coll once to build key map and render items\n              ^not-native new-keys\n              (-persistent!\n                (reduce-kv\n                  (fn [^not-native keys idx val]\n                    (let [key (kfn val)\n                          item (KeyedItem. key val nil false)]\n\n                      (aset new-items idx item)\n                      (-assoc! keys key item)))\n                  (-as-transient {})\n                  new-coll))]\n\n          (when (not= (-count new-keys) new-len)\n            (throw (ex-info \"collection contains duplicated keys\" {:coll new-coll :keys new-keys})))\n\n          (let [old-items\n                (.filter old-items\n                  (fn [^KeyedItem item]\n                    (if (contains? new-keys (.-key item))\n                      true\n                      (do (p/destroy! ^not-native (.-managed item) true)\n                          false))))]\n\n            ;; old-items now matches what is in the DOM and only contains items still present in new coll\n\n            ;; this can never be more items than the new coll\n            ;; but it might be less in cases where items were removed\n\n            ;; now going backwards over the new collection and apply render results to items\n            ;; reverse order because of only being able to insert before anchor\n\n            ;; will create new items while traversing\n            ;; will move items when required\n\n            (loop [anchor marker-after\n                   idx (dec new-len)\n                   old-idx (dec (alength old-items))]\n\n              (when-not (neg? idx)\n                (let [^KeyedItem new-item (aget new-items idx)\n                      ^KeyedItem old-item (get item-keys (.-key new-item))]\n\n                  (cond\n                    ;; item does not exist in old coll, just create and insert\n                    (not old-item)\n                    (let [rendered (rfn (.-data new-item) idx (.-key new-item))\n                          ^not-native managed (p/as-managed rendered env)]\n\n                      (p/dom-insert managed dom-parent anchor)\n\n                      ;; FIXME: call dom-entered! after syncing is done, item might not be in final position yet\n                      ;; other stuff may be inserted before it\n                      (when dom-entered?\n                        (p/dom-entered! managed))\n\n                      (set! new-item -managed managed)\n\n                      (recur (p/dom-first managed) (dec idx) old-idx))\n\n                    ;; item in same position, render update, move only when item was previously moved\n                    (identical? old-item (aget old-items old-idx))\n                    (let [^not-native managed (.-managed old-item)]\n                      ;; if the render-fn and data are identical we can skip over rendering them\n                      ;; since they rfn is supposed to be pure.\n                      ;; only checking identical? references since = may end up doing too much work\n                      ;; that the component/fragment will check again later anyways so we want to avoid\n                      ;; duplicating the work. skipping the rendering may save a couple allocation and\n                      ;; checks so this is worth doing when it can.\n\n                      ;; render-fn is never identical when using (render-seq coll key-fn (fn [data] ...))\n                      ;; but it is when using (render-seq coll key-fn component) or other function refs\n                      ;; that don't close over other data\n\n                      (if (and rfn-identical? (identical? (.-data old-item) (.-data new-item)))\n                        (do (set! new-item -managed managed)\n\n                            (when ^boolean (.-moved? old-item)\n                              ;; don't need to do this I think, never using old-item again\n                              ;; (set! old-item -moved? false)\n                              (p/dom-insert managed dom-parent anchor))\n\n                            (recur (p/dom-first managed) (dec idx) (dec old-idx)))\n\n                        ;; need to render\n                        (let [rendered (rfn (.-data new-item) idx (.-key new-item))]\n                          (if (p/supports? managed rendered)\n                            ;; update in place if supported\n                            (do (p/dom-sync! managed rendered)\n                                (set! new-item -managed managed)\n\n                                ;; item was previously moved, move in DOM now\n                                (when ^boolean (.-moved? old-item)\n                                  ;; don't need to do this I think, never using old-item again\n                                  ;; (set! old-item -moved? false)\n                                  (p/dom-insert managed dom-parent anchor))\n\n                                (recur (p/dom-first managed) (dec idx) (dec old-idx)))\n\n                            ;; not updatable, swap.\n                            ;; unlikely given that key was the same, result should be the same.\n                            ;; still possible though\n                            (let [^not-native new-managed (p/as-managed rendered env)]\n                              (p/dom-insert new-managed dom-parent anchor)\n                              (when dom-entered?\n                                (p/dom-entered! new-managed))\n                              (p/destroy! managed true)\n                              (set! new-item -managed new-managed)\n                              (recur (p/dom-first new-managed) (dec idx) (dec old-idx))\n                              )))))\n\n                    ;; item not in proper position, find it and move it here\n                    ;; FIXME: this starts looking at the front of the collection\n                    ;; this might be a performance drain when collection is shuffled too much\n                    :else\n                    (let [seek-idx (.indexOf old-items old-item)\n                          ^KeyedItem old-item (aget old-items seek-idx)\n                          ^not-native managed (.-managed old-item)\n\n                          ;; current tail item\n                          ^KeyedItem item-at-idx (aget old-items old-idx)]\n\n                      (set! item-at-idx -moved? true)\n                      (aset old-items seek-idx item-at-idx)\n                      (aset old-items old-idx old-item)\n\n                      ;; again, may skip rendering if fully identical\n                      ;; still need to move it though\n                      (if (and rfn-identical? (identical? (.-data new-item) (.-data old-item)))\n                        (do (set! new-item -managed managed)\n                            (p/dom-insert managed dom-parent anchor)\n                            (recur (p/dom-first managed) (dec idx) (dec old-idx)))\n\n                        ;; can't skip rendering\n                        (let [rendered (rfn (.-data new-item) idx (.-key new-item))]\n                          (if (p/supports? managed rendered)\n                            ;; update in place if supported\n                            (do (set! new-item -managed managed)\n                                (p/dom-sync! managed rendered)\n                                (p/dom-insert managed dom-parent anchor)\n                                (recur (p/dom-first managed) (dec idx) (dec old-idx)))\n\n                            ;; not updatable, swap.\n                            ;; unlikely given that key was the same, result should be the same.\n                            ;; still possible though\n                            (let [^not-native new-managed (p/as-managed rendered env)]\n                              (set! new-item -managed new-managed)\n                              (p/dom-insert new-managed dom-parent anchor)\n                              (when dom-entered?\n                                (p/dom-entered! new-managed))\n                              (p/destroy! managed true)\n                              (recur (p/dom-first new-managed) (dec idx) (dec old-idx))\n                              ))))))))))\n\n          (set! item-keys new-keys)\n          (set! items new-items))))\n    :synced)\n\n  (destroy! [this ^boolean dom-remove?]\n    (when dom-remove?\n      (doto (js/document.createRange)\n        (.setStartBefore marker-before)\n        (.setEndAfter marker-after)\n        (.deleteContents)))\n\n    (.forEach items\n      (fn [item]\n        (p/destroy! ^not-native (.-managed item) false)))))\n\n(deftype KeyedCollectionInit [coll key-fn render-fn]\n  p/IConstruct\n  (as-managed [this env]\n    (let [len (count coll)\n          marker-before (common/dom-marker env \"coll-start\")\n          marker-after (common/dom-marker env \"coll-end\")\n\n          kfn (common/ifn1-wrap key-fn)\n          rfn (common/ifn3-wrap render-fn)\n\n          items (js/Array. len)\n\n          ;; {<key> <item>}, same instance as in array\n          keys\n          (persistent!\n            (reduce-kv\n              (fn [keys idx val]\n                (let [key (kfn val)\n                      rendered (rfn val idx key)\n                      managed (p/as-managed rendered env)\n                      item (KeyedItem. key val managed false)]\n\n                  (aset items idx item)\n                  (assoc! keys key item)))\n              (transient {})\n              coll))]\n\n      (when (not= (count keys) len)\n        (throw (ex-info \"collection contains duplicated keys\" {})))\n\n      (KeyedCollection.\n        env\n        coll\n        key-fn\n        render-fn\n        items\n        keys\n        marker-before\n        marker-after\n        false)))\n\n  IEquiv\n  (-equiv [this ^KeyedCollectionInit other]\n    (and (instance? KeyedCollectionInit other)\n         ;; could be a keyword, can't use identical?\n         (keyword-identical? key-fn (.-key-fn other))\n         ;; FIXME: this makes it never equal if fn is created in :render fn\n         (identical? render-fn (.-render-fn other))\n         ;; compare coll last since its pointless if the others changed and typically more expensive to compare\n         (= coll (.-coll other)))))\n\n(defn keyed-seq [coll key-fn render-fn]\n  {:pre [(sequential? coll)\n         (ifn? key-fn)\n         (ifn? render-fn)]}\n\n  ;; we always need compatible collections, it should already be a vector in most cases\n  ;; it must not allow lazy sequences since the sequence may not be used immediately\n  ;; some item may suspend and whatever the lazy seq did will happen in totally different phases\n  ;; cannot guarantee that some other data it previously may have relied upon is still valid\n  (let [coll (vec coll)]\n    (if (zero? (count coll))\n      nil ;; can skip much unneeded work for empty colls\n      (KeyedCollectionInit. coll key-fn render-fn))))\n\n(declare SimpleCollectionInit)\n\n(deftype SimpleItem [data managed])\n\n(deftype SimpleCollection\n  [env\n   ^:mutable coll\n   ^:mutable ^function render-fn\n   ^:mutable ^array items\n   marker-before\n   marker-after\n   ^boolean ^:mutable dom-entered?]\n\n  p/IManaged\n  (dom-first [this] marker-before)\n\n  (dom-insert [this parent anchor]\n    (.insertBefore parent marker-before anchor)\n    (.forEach items\n      (fn [^SimpleItem item]\n        (p/dom-insert ^not-native (.-managed item) parent anchor)))\n    (.insertBefore parent marker-after anchor))\n\n  (dom-entered! [this]\n    (set! dom-entered? true)\n    (.forEach items\n      (fn [^SimpleItem item]\n        (p/dom-entered! ^not-native (.-managed item)))))\n\n  (supports? [this next]\n    (instance? SimpleCollectionInit next))\n\n  (dom-sync! [this ^SimpleCollectionInit next]\n    (let [rfn-identical? (identical? render-fn (.-render-fn next))\n\n          ^not-native old-coll coll\n          ^not-native new-coll (.-coll next)]\n\n      ;; only checking identical since we want to avoid deep comparisons for items\n      ;; since the rendered results will likely do that again\n      (when-not (and rfn-identical? (identical? old-coll new-coll))\n\n        (let [dom-parent (.-parentNode marker-after)\n\n              oc (-count old-coll)\n              nc (-count new-coll)\n\n              max-idx (js/Math.min oc nc)]\n\n          (when-not dom-parent\n            (throw (ex-info \"sync while not in dom?\" {})))\n\n          (set! coll new-coll)\n          (set! render-fn (.-render-fn next))\n\n          (let [^function rfn (common/ifn2-wrap render-fn)]\n\n            (dotimes [idx max-idx]\n              (let [^SimpleItem item (aget items idx)\n                    ^not-native managed (.-managed item)\n                    new-data (-nth new-coll idx)]\n\n                (when-not (and rfn-identical? (identical? new-data (.-data item)))\n\n                  (let [new-rendered (rfn new-data idx)]\n                    (set! item -data new-data)\n\n                    (if (p/supports? managed new-rendered)\n                      (p/dom-sync! managed new-rendered)\n                      (let [new-managed (common/replace-managed env managed new-rendered)]\n                        (when dom-entered?\n                          (p/dom-entered! new-managed))\n\n                        (set! item -managed new-managed)))))))\n\n            (cond\n              (= oc nc)\n              :done\n\n              ;; old had more items, remove tail\n              ;; FIXME: might be faster to remove in last one first? less node re-ordering\n              (> oc nc)\n              (do (dotimes [idx (- oc nc)]\n                    (let [idx (+ max-idx idx)\n                          ^SimpleItem item (aget items idx)]\n                      (p/destroy! ^not-native (.-managed item) true)))\n                  (set! (.-length items) max-idx))\n\n              ;; old had fewer items, append at end\n              (< oc nc)\n              (dotimes [idx (- nc oc)]\n                (let [idx (+ max-idx idx)\n                      data (-nth new-coll idx)\n                      rendered (rfn data idx)\n                      managed (p/as-managed rendered env)]\n                  (.push items (SimpleItem. data managed))\n                  (p/dom-insert managed dom-parent marker-after)\n                  (when dom-entered?\n                    (p/dom-entered! managed)))))))))\n\n    :synced)\n\n  (destroy! [this ^boolean dom-remove?]\n    (when dom-remove?\n      (doto (js/document.createRange)\n        (.setStartBefore marker-before)\n        (.setEndAfter marker-after)\n        (.deleteContents)))\n\n    (.forEach items\n      (fn [^SimpleItem item]\n        (p/destroy! ^not-native (.-managed item) false)))\n    ))\n\n(deftype SimpleCollectionInit [coll render-fn]\n  p/IConstruct\n  (as-managed [this env]\n    (let [marker-before (common/dom-marker env \"coll-start\")\n          marker-after (common/dom-marker env \"coll-end\")\n          arr (js/Array. (count coll))\n          rfn (common/ifn2-wrap render-fn)]\n\n      (reduce-kv\n        (fn [_ idx data]\n          (aset arr idx (SimpleItem. data (p/as-managed (rfn data idx) env))))\n        nil\n        coll)\n\n      (SimpleCollection. env coll render-fn arr marker-before marker-after false)))\n\n  IEquiv\n  (-equiv [this ^SimpleCollectionInit other]\n    (and (instance? SimpleCollectionInit other)\n         ;; could be a keyword, can't use identical?\n         ;; FIXME: this makes it never equal if fn is created in :render fn\n         (identical? render-fn (.-render-fn other))\n         ;; compare coll last since its pointless if the others changed and typically more expensive to compare\n         (= coll (.-coll other)))))\n\n(defn simple-seq [coll render-fn]\n  {:pre [(sequential? coll)\n         (ifn? render-fn)]}\n  (let [coll (vec coll)]\n    (if (zero? (count coll))\n      nil ;; can skip much unneeded work for empty colls\n      (SimpleCollectionInit. coll render-fn))))\n"]}