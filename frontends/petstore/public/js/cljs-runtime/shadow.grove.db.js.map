{"version":3,"sources":["shadow/grove/db.cljc"],"mappings":"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","names":["shadow.grove.db/make-ident","type","id","shadow.grove.db.ident/->Ident","shadow.grove.db/ident?","thing","shadow.grove.db.ident/ident?","js/Error","shadow.grove.db/ident-key","shadow.grove.db/ident-val","shadow.grove.db/ident-as-vec","ident","shadow.grove.db/parse-joins","spec","joins","cljs.core/reduce-kv","attr","val","cljs.core/vector?","cljs.core._EQ_","cljs.core/first","cljs.core.ex_info","cljs.core.update","cljs.core/assoc","cljs.core/second","p__12175","p__12176","map__12177","cljs.core/--destructure-map","cljs.core.get","map__12178","shadow.grove.db/parse-primary-key","entity-type","primary-key","config","and__5043__auto__","cljs.core/not","cljs.core/Keyword","p1__12173#","cljs.core.assoc","cljs.core/every?","cljs.core/keyword?","item","p1__12174#","cljs.core.mapv","p__12183","map__12184","shadow.grove.db/parse-entity-spec","shadow.grove.db/parse-schema","p__12190","map__12191","schema","key","cljs.core/assoc-in","shadow.grove.db/nav-fn","db","cljs.core/coll?","cljs.core.vary_meta","m","shadow.grove.db/configure","init-db","cljs.core/set","cljs.core/keys","cljs.core/with-meta","shadow.grove.db/coll-key","shadow.grove.db/normalize*","imports","map__12195","ident-gen","id-pred","ent-config","cljs.core.get_in","item-ident","_","cljs.core.not_EQ_","join-type","curr-val","norm-val","cljs.core/keyword-identical?","cljs.core/map?","p1__12194#","cljs.core/type","cljs.core.swap_BANG_","cljs.core/conj","shadow.grove.db/normalize","vals","cljs.core/deref","cljs.core.atom","cljs.core/sequential?","seq__12202","cljs.core/seq","chunk__12203","count__12204","i__12205","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/next","shadow.grove.db/set-conj","x","y","cljs.core.conj","shadow.grove.db/merge-or-replace","left","right","cljs.core.merge","shadow.grove.db/merge-imports","data","cljs.core.reduce","p__12222","vec__12223","cljs.core.nth","var_args","G__12235","shadow.grove.db/merge-seq","coll","shadow.grove.db.merge_seq","target-path-or-fn","map__12245","map__12246","cljs.core/meta","entity-spec","idents","cljs.core.map","cljs.core.into","G__12247","cljs.core/fn?","G__12250","shadow.grove.db/add","shadow.grove.db.add","target-path","map__12254","map__12255","G__12256","cljs.core.update_in","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","shadow.grove.db/update-entity","seq12266","G__12267","G__12268","G__12269","G__12270","self__5754__auto__","update-fn","args","p1__12265#","cljs.core.apply","shadow.grove.db/all-idents-of","shadow.grove.db/all-of","p1__12286#","shadow.grove.db/remove","cljs.core.dissoc","shadow.grove.db/remove-idents","shadow$grove$db$IObserved$observed_keys$dyn","x__5393__auto__","m__5394__auto__","shadow.grove.db/observed-keys","goog/typeOf","m__5392__auto__","cljs.core/missing-protocol","shadow.grove.db/IObserved","this","cljs.core/PROTOCOL_SENTINEL","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","shadow.grove.db/ObservedData","shadow.grove.db/->ObservedData","keys-used","cljs.core/persistent!","k","v","cljs.core.conj_BANG_","default","shadow.grove.db/observed","cljs.core/transient","shadow$grove$db$ITxCommit$commit_BANG_$dyn","shadow.grove.db/commit!","shadow.grove.db/ITxCommit","shadow.grove.db/TransactedData","shadow.grove.db/->TransactedData","keys-new","keys-updated","keys-removed","completed-ref","key-is-ident?","next-data","G__12392","cljs.core/disj","next-removed","G__12396","value","prev-val","is-ident-update?","cljs.core/contains?","entry","ret","es","e","cljs.core/-assoc","cljs.core/vreset!","shadow.grove.db/transacted","cljs.core/volatile!"],"sourcesContent":["(ns shadow.grove.db\n  (:refer-clojure :exclude (ident? remove))\n  (:require [shadow.grove.db.ident :as ident]))\n\n#?(:cljs\n   (set! *warn-on-infer* false))\n\n#?(:clj\n   (defn keyword-identical? [a b]\n     (identical? a b)))\n\n(defn make-ident [type id]\n  #?(:clj (ident/->Ident type id)\n     :cljs (ident/->Ident type id nil)))\n\n(defn ident? [thing]\n  (ident/ident? thing))\n\n(defn ident-key [thing]\n  {:pre [(ident/ident? thing)]}\n  #?(:clj (:entity-type thing)\n     :cljs (.-entity-type ^Ident thing)))\n\n(defn ident-val [thing]\n  {:pre [(ident/ident? thing)]}\n  #?(:clj (:id thing)\n     :cljs (.-id ^Ident thing)))\n\n(defn ident-as-vec [ident]\n  [(ident-key ident)\n   (ident-val ident)])\n\n(defn parse-joins [spec joins]\n  (reduce-kv\n    (fn [spec attr val]\n      (if-not (and (vector? val)\n                   (or (= :one (first val))\n                       (= :many (first val))))\n        (throw (ex-info \"invalid join\" joins))\n\n        ;; FIXME: actually make use of :one/:many, right now relying and user supplying proper value\n        (update spec :joins assoc attr (second val))))\n    spec\n    joins))\n\n(defn parse-primary-key\n  [{:keys [entity-type] :as spec}\n   {:keys [primary-key] :as config}]\n  (cond\n    (and (not primary-key) (:ident-gen config))\n    spec\n\n    (keyword? primary-key)\n    (assoc spec\n      :ident-gen\n      #(make-ident entity-type (get % primary-key)))\n\n    (and (vector? primary-key) (every? keyword? primary-key))\n    (assoc spec\n      :ident-gen\n      (fn [item]\n        (make-ident entity-type\n          (mapv #(get item %) primary-key))))\n\n    :else\n    (throw (ex-info \"invalid :primary-key\" config))))\n\n(defn parse-entity-spec [entity-type {:keys [joins] :as config}]\n  {:pre [(keyword? entity-type)]}\n\n  (-> (assoc config :entity-type entity-type :joins {})\n      (parse-primary-key config)\n      (parse-joins joins)\n      ))\n\n(defn parse-schema [spec]\n  (reduce-kv\n    (fn [schema key {:keys [type] :as config}]\n      (cond\n        (= :entity type)\n        (assoc-in schema [:entities key] (parse-entity-spec key config))\n\n        ;; only have entities for now, will need custom config later\n        :else\n        (throw (ex-info \"unknown type\" {:key key :config config}))\n        ))\n    {:entities {}}\n    spec))\n\n(defn nav-fn [db key val]\n  (cond\n    (ident? val)\n    (get db val)\n\n    (coll? val)\n    (vary-meta val assoc\n      'clojure.core.protocols/datafy\n      (fn [m]\n        (vary-meta m assoc\n          'clojure.core.protocols/nav\n          (fn [m key val]\n            (if (ident? val)\n              (get db val)\n              val)))))\n\n    :else\n    val))\n\n(defn configure [init-db spec]\n  ;; FIXME: should this use a special key instead of meta?\n  (let [schema (parse-schema spec)\n        m {::schema schema\n           ::ident-types (set (keys (:entities schema)))\n           ;; FIXME: conditionalize this, not necessary in release builds\n           ;; convenient for when tapping the db for inspect\n           'clojure.core.protocols/nav nav-fn}]\n\n    (with-meta init-db m)))\n\n\n(defn coll-key [thing]\n  {:pre [(ident? thing)]}\n  [::all (ident-key thing)])\n\n\n(defn- normalize* [imports schema entity-type item]\n  (let [{:keys [ident-gen id-pred joins] :as ent-config}\n        (get-in schema [:entities entity-type])\n\n        item-ident\n        (get item :db/ident)\n\n        ident\n        (ident-gen item)\n\n        _ (when (and item-ident (not= item-ident ident))\n            (throw (ex-info \"item contained ident but we generated a different one\" {:item item :ident ident})))\n\n        ;; FIXME: can an item ever have more than one ident?\n        item\n        (if (= item-ident ident)\n          item\n          (assoc item :db/ident ident))\n\n        item\n        (reduce-kv\n          (fn [item key join-type]\n            (let [curr-val\n                  (get item key ::skip)\n\n                  norm-val\n                  (cond\n                    (keyword-identical? ::skip curr-val)\n                    curr-val\n\n                    ;; already normalized, no nothing\n                    (ident? curr-val)\n                    ::skip\n\n                    (map? curr-val)\n                    (normalize* imports schema join-type curr-val)\n\n                    (vector? curr-val)\n                    (mapv #(normalize* imports schema join-type %) curr-val)\n\n                    ;; FIXME: add back predicate to check if curr-val is valid id-val to make ident\n                    ;; might be garbage leading to invalid ident stored in norm db\n                    (some? curr-val)\n                    (make-ident join-type curr-val)\n\n                    :else\n                    (throw (ex-info \"unexpected value in join attr\"\n                             {:item item\n                              :key key\n                              :val curr-val\n                              :type type})))]\n\n              (if (keyword-identical? norm-val ::skip)\n                item\n                (assoc item key norm-val))))\n          item\n          joins)]\n\n    (swap! imports conj [ident item])\n\n    ident))\n\n(defn- normalize\n  \"returns a seq of [[ident item] ...] tuples\"\n  [schema entity-type vals]\n  (let [imports (atom [])]\n\n    (cond\n      (map? vals)\n      (normalize* imports schema entity-type vals)\n\n      (sequential? vals)\n      (doseq [item vals]\n        (normalize* imports schema entity-type item))\n\n      :else\n      (throw (ex-info \"cannot import\" {:entity-type entity-type :vals vals})))\n\n    @imports\n    ))\n\n(comment\n  (let [schema\n        {:foo\n         {:type :entity\n          :primary-key :foo-id\n          :joins {:bar [:one :bar]\n                  :baz [:one :baz]}}\n         :bar\n         {:type :entity\n          :primary-key :bar-id}}\n\n        db\n        (configure {} schema)]\n\n    (-> (transacted db)\n        (add :foo {:foo-id 1 :foo \"foo\" :bar {:bar-id 1 :bar \"bar\"}})\n        (commit!)\n        (get :data))))\n\n(defn- set-conj [x y]\n  (if (nil? x)\n    #{y}\n    (conj x y)))\n\n(defn merge-or-replace [left right]\n  (if (keyword-identical? :db/loading left)\n    right\n    (merge left right)))\n\n(defn- merge-imports [data imports]\n  (reduce\n    (fn [data [ident item]]\n      (update data ident merge-or-replace item))\n    data\n    imports))\n\n(defn merge-seq\n  ([data entity-type coll]\n   (merge-seq data entity-type coll nil))\n  ([data entity-type coll target-path-or-fn]\n   {:pre [(sequential? coll)]}\n   (let [{::keys [schema]}\n         (meta data)\n\n         _ (when-not schema\n             (throw (ex-info \"data missing schema\" {:data data})))\n\n         {:keys [ident-gen] :as entity-spec}\n         (get-in schema [:entities entity-type])\n\n         _ (when-not entity-spec\n             (throw (ex-info \"entity not defined\" {:entity-type entity-type})))\n\n         idents\n         (->> coll\n              (map ident-gen)\n              (into []))\n\n         imports\n         (normalize schema entity-type coll)]\n\n     (-> data\n         (merge-imports imports)\n         (cond->\n           (vector? target-path-or-fn)\n           (assoc-in target-path-or-fn idents)\n\n           (fn? target-path-or-fn)\n           (target-path-or-fn idents))\n         ))))\n\n(defn add\n  ([data entity-type item]\n   (add data entity-type item nil))\n  ([data entity-type item target-path]\n   {:pre [(map? item)]}\n   (let [{::keys [schema]}\n         (meta data)\n\n         _ (when-not schema\n             (throw (ex-info \"data missing schema\" {:data data})))\n\n         {:keys [ident-gen] :as entity-spec}\n         (get-in schema [:entities entity-type])\n\n         _ (when-not entity-spec\n             (throw (ex-info \"entity not defined\" {:entity-type entity-type})))\n\n         ident\n         (ident-gen item)\n\n         imports\n         (normalize schema entity-type [item])]\n\n     (-> data\n         (merge-imports imports)\n         (cond->\n           target-path\n           (update-in target-path conj ident))))))\n\n(defn update-entity [data entity-type id update-fn & args]\n  ;; FIXME: validate that both entity-type is defined and id matches type\n  (update data (make-ident entity-type id) #(apply update-fn % args)))\n\n(defn all-idents-of [db entity-type]\n  ;; FIXME: check in schema if entity-type is actually declared\n  (get db [::all entity-type]))\n\n(defn all-of [db entity-type]\n  (->> (all-idents-of db entity-type)\n       (map #(get db %))))\n\n;; keep this as the very last thing since we excluded clojure remove\n;; don't want to write code that assumes it uses core remove\n(defn remove [data thing]\n  (cond\n    (ident? thing)\n    (dissoc data thing)\n\n    (and (map? thing) (:db/ident thing))\n    (dissoc data (:db/ident thing))\n\n    :else\n    (throw (ex-info \"don't know how to remove thing\" {:thing thing}))))\n\n(defn remove-idents [data idents]\n  (reduce remove data idents))\n\n(defprotocol IObserved\n  (observed-keys [this]))\n\n#?(:clj\n   (deftype ObservedData\n     [^:unsynchronized-mutable keys-used\n      ^clojure.lang.IPersistentMap data]\n     IObserved\n     (observed-keys [_]\n       (persistent! keys-used))\n\n     clojure.lang.IMeta\n     (meta [_]\n       (.meta data))\n\n     ;; FIXME: implement rest of seq functions\n\n     clojure.lang.IPersistentMap\n     (assoc [this key val]\n       (throw (ex-info \"read-only\" {})))\n\n     (assocEx [this key val]\n       (throw (ex-info \"read-only\" {})))\n\n     (without [this key]\n       (throw (ex-info \"read-only\" {})))\n\n     (containsKey [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (.containsKey data key))\n\n     (valAt [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (.valAt data key))\n\n     (valAt [this key not-found]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (.valAt data key not-found))\n\n     (entryAt [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (.entryAt data key)))\n\n   :cljs\n   (deftype ObservedData [^:mutable keys-used ^not-native data]\n     IObserved\n     (observed-keys [_]\n       (persistent! keys-used))\n\n     IMeta\n     (-meta [_]\n       (-meta data))\n\n     ;; map? predicate checks for this protocol\n     IMap\n     (-dissoc [coll k]\n       (throw (ex-info \"observed data is read-only\" {})))\n\n     IAssociative\n     (-contains-key? [coll k]\n       (-contains-key? data k))\n     (-assoc [coll k v]\n       (throw (ex-info \"observed data is read-only, assoc not allowed\" {:k k :v v})))\n\n     ILookup\n     (-lookup [_ key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (-lookup data key))\n\n     (-lookup [_ key default]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (-lookup data key default))))\n\n(defn observed [data]\n  (ObservedData. (transient #{}) data))\n\n#?(:clj\n   (defprotocol ITxCheck\n     (check-completed! [this])))\n\n(defprotocol ITxCommit\n  (commit! [this]))\n\n#?(:clj\n   (deftype TransactedData\n     [^clojure.lang.IPersistentMap data\n      keys-new\n      keys-updated\n      keys-removed\n      ;; using a ref not a mutable local since it must apply to all created instances of this\n      ;; every \"write\" creates a new instance\n      completed-ref]\n\n     ;; useful for debugging purposes that want the actual data\n     clojure.lang.IDeref\n     (deref [_]\n       data)\n\n     clojure.lang.IMeta\n     (meta [_]\n       (.meta data))\n\n     clojure.lang.IPersistentMap\n     (count [this]\n       (.count data))\n\n     (containsKey [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (.containsKey data key))\n\n     (valAt [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (.valAt data key))\n\n     (valAt [this key not-found]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (.valAt data key not-found))\n\n     (entryAt [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (.entryAt data key))\n\n     (assoc [this key value]\n       (check-completed! this)\n\n       (when (nil? key)\n         (throw (ex-info \"nil key not allowed\" {:value value})))\n\n       ;; FIXME: should it really check each write if anything changed?\n       ;; FIXME: enforce that ident keys have a map value with ::ident key?\n       (let [prev-val\n             (.valAt data key ::not-found)\n\n             ;; FIXME: this should only be checking the key\n             ;; but since using vectors as ident we can't tell the difference from\n             ;; [::all :some.app.model/thing]\n             is-ident-update?\n             (and (ident? key)\n                  (contains? (::ident-types (meta data)) (ident-key key)))]\n\n         (if (identical? prev-val value)\n           this\n           (if (= ::not-found prev-val)\n             ;; new\n             (if-not is-ident-update?\n               ;; new non-ident key\n               (TransactedData.\n                 (assoc data key value)\n                 (conj! keys-new key)\n                 keys-updated\n                 keys-removed\n                 completed-ref)\n\n               ;; new ident\n               (TransactedData.\n                 (-> data\n                     (assoc key value)\n                     (update (coll-key key) set-conj key))\n                 (conj! keys-new key)\n                 (conj! keys-updated (coll-key key))\n                 keys-removed\n                 completed-ref))\n\n             ;; update, non-ident key\n             (if-not is-ident-update?\n               (TransactedData.\n                 (assoc data key value)\n                 (conj! keys-updated key)\n                 (conj! keys-updated key)\n                 keys-removed\n                 completed-ref)\n\n               ;; FIXME: no need to track (ident-key key) since it should be present?\n               (TransactedData.\n                 (.assoc data key value)\n                 keys-new\n                 (-> keys-updated\n                     (conj! key)\n                     ;; need to update the entity-type collection since some queries might change if one in the list changes\n                     ;; FIXME: this makes any update potentially expensive, maybe should leave this to the user?\n                     (conj! (coll-key key)))\n                 keys-removed\n                 completed-ref))\n             ))))\n\n     (assocEx [this key value]\n       (check-completed! this)\n\n       (when (nil? key)\n         (throw (ex-info \"nil key not allowed\" {:value value})))\n\n       ;; FIXME: should it really check each write if anything changed?\n       ;; FIXME: enforce that ident keys have a map value with ::ident key?\n       (let [prev-val\n             (.valAt data key ::not-found)\n\n             ;; FIXME: this should only be checking the key\n             ;; but since using vectors as ident we can't tell the difference from\n             ;; [::all :some.app.model/thing]\n             is-ident-update?\n             (and (ident? key)\n                  (contains? (::ident-types (meta data)) (ident-key key)))]\n\n         (if (identical? prev-val value)\n           this\n           (if (= ::not-found prev-val)\n             ;; new\n             (if-not is-ident-update?\n               ;; new non-ident key\n               (TransactedData.\n                 (.assocEx data key value)\n                 (conj! keys-new key)\n                 keys-updated\n                 keys-removed\n                 completed-ref)\n\n               ;; new ident\n               (TransactedData.\n                 (-> data\n                     (.assocEx key value)\n                     (update (coll-key key) set-conj key))\n                 (conj! keys-new key)\n                 (conj! keys-updated (coll-key key))\n                 keys-removed\n                 completed-ref))\n\n             ;; update, non-ident key\n             (if-not is-ident-update?\n               (TransactedData.\n                 (.assocEx data key value)\n                 keys-new\n                 (conj! keys-updated key)\n                 keys-removed\n                 completed-ref)\n\n               ;; FIXME: no need to track (ident-key key) since it should be present?\n               (TransactedData.\n                 (.assocEx data key value)\n                 keys-new\n                 (-> keys-updated\n                     (conj! key)\n                     ;; need to update the entity-type collection since some queries might change if one in the list changes\n                     ;; FIXME: this makes any update potentially expensive, maybe should leave this to the user?\n                     (conj! (coll-key key)))\n                 keys-removed\n                 completed-ref))\n             ))))\n\n     (without [this key]\n       (check-completed! this)\n\n       (let [key-is-ident?\n             (ident? key)\n\n             next-data\n             (-> (.without data key)\n                 (cond->\n                   key-is-ident?\n                   (update (coll-key key) disj key)))\n\n             next-removed\n             (-> keys-removed\n                 (conj! key)\n                 (cond->\n                   key-is-ident?\n                   (conj! (coll-key key))))]\n\n         (TransactedData.\n           next-data\n           keys-new\n           keys-updated\n           next-removed\n           completed-ref)))\n\n     ITxCheck\n     (check-completed! [this]\n       (when @completed-ref\n         (throw (ex-info \"transaction concluded, don't hold on to db while in tx\" {}))))\n\n     ITxCommit\n     (commit! [_]\n       (vreset! completed-ref true)\n       {:data data\n        :keys-new (persistent! keys-new)\n        :keys-updated (persistent! keys-updated)\n        :keys-removed (persistent! keys-removed)}))\n\n   :cljs\n   (deftype TransactedData\n     [^not-native data\n      keys-new\n      keys-updated\n      keys-removed\n      ;; using a ref not a mutable local since it must apply to all created instances of this\n      ;; every \"write\" creates a new instance\n      completed-ref]\n\n     ;; useful for debugging purposes that want the actual data\n     IDeref\n     (-deref [_]\n       data)\n\n     IMeta\n     (-meta [_]\n       (-meta data))\n\n     ILookup\n     (-lookup [this key]\n       (.check-completed! this)\n       (-lookup data key))\n\n     (-lookup [this key default]\n       (.check-completed! this)\n       (-lookup data key default))\n\n     ICounted\n     (-count [this]\n       (.check-completed! this)\n       (-count data))\n\n     IMap\n     (-dissoc [this key]\n       (.check-completed! this)\n\n       (let [key-is-ident?\n             (ident? key)\n\n             next-data\n             (-> (-dissoc data key)\n                 (cond->\n                   key-is-ident?\n                   (update (coll-key key) disj key)))\n\n             next-removed\n             (-> keys-removed\n                 (conj! key)\n                 (cond->\n                   key-is-ident?\n                   (conj! (coll-key key))))]\n\n         (TransactedData.\n           next-data\n           keys-new\n           keys-updated\n           next-removed\n           completed-ref)))\n\n     IAssociative\n     (-contains-key? [coll k]\n       (-contains-key? data k))\n\n     (-assoc [this key value]\n       (.check-completed! this)\n\n       (when (nil? key)\n         (throw (ex-info \"nil key not allowed\" {:value value})))\n\n       ;; FIXME: should it really check each write if anything changed?\n       ;; FIXME: enforce that ident keys have a map value with ::ident key?\n       (let [prev-val\n             (-lookup data key ::not-found)\n\n             ;; FIXME: this should only be checking the key\n             ;; but since using vectors as ident we can't tell the difference from\n             ;; [::all :some.app.model/thing]\n             is-ident-update?\n             (and (ident? key)\n                  (contains? (::ident-types (meta data)) (ident-key key)))]\n\n         (if (identical? prev-val value)\n           this\n           (if (= ::not-found prev-val)\n             ;; new\n             (if-not is-ident-update?\n               ;; new non-ident key\n               (TransactedData.\n                 (-assoc data key value)\n                 (conj! keys-new key)\n                 keys-updated\n                 keys-removed\n                 completed-ref)\n\n               ;; new ident\n               (TransactedData.\n                 (-> data\n                     (-assoc key value)\n                     (update (coll-key key) set-conj key))\n                 (conj! keys-new key)\n                 (conj! keys-updated (coll-key key))\n                 keys-removed\n                 completed-ref))\n\n             ;; update, non-ident key\n             (if-not is-ident-update?\n               (TransactedData.\n                 (-assoc data key value)\n                 keys-new\n                 (conj! keys-updated key)\n                 keys-removed\n                 completed-ref)\n\n               ;; FIXME: no need to track (ident-key key) since it should be present?\n               (TransactedData.\n                 (-assoc data key value)\n                 keys-new\n                 (-> keys-updated\n                     (conj! key)\n                     ;; need to update the entity-type collection since some queries might change if one in the list changes\n                     ;; FIXME: this makes any update potentially expensive, maybe should leave this to the user?\n                     (conj! (coll-key key)))\n                 keys-removed\n                 completed-ref))\n             ))))\n\n     ICollection\n     (-conj [coll ^not-native entry]\n       (if (vector? entry)\n         (-assoc coll (-nth entry 0) (-nth entry 1))\n         (loop [^not-native ret coll\n                es (seq entry)]\n           (if (nil? es)\n             ret\n             (let [^not-native e (first es)]\n               (if (vector? e)\n                 (recur\n                   (-assoc ret (-nth e 0) (-nth e 1))\n                   (next es))\n                 (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n     ITxCommit\n     (commit! [_]\n       (vreset! completed-ref true)\n       {:data data\n        :keys-new (persistent! keys-new)\n        :keys-updated (persistent! keys-updated)\n        :keys-removed (persistent! keys-removed)})\n\n     Object\n     (check-completed! [this]\n       (when @completed-ref\n         (throw (ex-info \"transaction concluded, don't hold on to db while in tx\" {}))))))\n\n(defn transacted [data]\n  (TransactedData.\n    data\n    (transient #{})\n    (transient #{})\n    (transient #{})\n    (volatile! false)))"]}