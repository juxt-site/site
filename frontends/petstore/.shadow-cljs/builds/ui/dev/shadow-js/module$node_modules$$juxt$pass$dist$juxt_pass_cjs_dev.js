["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@juxt/pass/dist/juxt-pass.cjs.dev.js"],"~:js","shadow$provide.module$node_modules$$juxt$pass$dist$juxt_pass_cjs_dev=function(global,require,module,exports){function generateRandomString(){const array=new Uint32Array(14);self.crypto.getRandomValues(array);return Array.from(array,dec=>(\"0\"+dec.toString(16)).substring(-2)).join(\"\")}async function pkceChallengeFromVerifier(v){v=(new TextEncoder).encode(v);v=await self.crypto.subtle.digest(\"SHA-256\",v);v=Array.from(new Uint8Array(v));return window.btoa(String.fromCharCode.apply(null,v)).replace(/\\+/g,\n\"-\").replace(/\\//g,\"_\").replace(/=+$/,\"\")}async function authorizationCodeRequestInfo({authorization_endpoint,client_id,redirect_uri,requested_scopes}){const state=generateRandomString(),code_verifier=generateRandomString(),code_challenge=await pkceChallengeFromVerifier(code_verifier);client_id=new URLSearchParams({response_type:\"code\",client_id,state,redirect_uri,code_challenge,code_challenge_method:\"S256\",...(requested_scopes&&requested_scopes.length&&{scope:requested_scopes.join(\" \")})});return{url:`${authorization_endpoint}?${client_id.toString()}`,\nstate,code_verifier}}async function postMessageToWorker(obj){(await navigator.serviceWorker.ready).active?.postMessage(obj)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.authorize=async function(config){postMessageToWorker({type:\"storeConfig\",config});const {url,state,code_verifier}=await authorizationCodeRequestInfo(config);localStorage.setItem(\"pkce_state\",state);localStorage.setItem(\"pkce_code_verifier\",code_verifier);localStorage.setItem(\"oauth2_client_id\",config.client_id);localStorage.setItem(\"oauth2_token_endpoint\",\nconfig.token_endpoint);localStorage.setItem(\"oauth2_redirect_uri\",config.redirect_uri);window.open(url)};exports.exchangeCodeForAccessToken=function({query_params}){var storedState=localStorage.getItem(\"pkce_state\"),queryParamState=query_params.get(\"state\");if((query_params=query_params.get(\"code\"))&&queryParamState){if(storedState!==queryParamState)throw Error(\"exchangeCodeForAccessToken mismatch between stored state and query param state\");storedState=localStorage.getItem(\"oauth2_redirect_uri\")||\n\"\";queryParamState=localStorage.getItem(\"oauth2_client_id\")||\"\";var code_verifier=localStorage.getItem(\"pkce_code_verifier\")||\"\";query_params=new URLSearchParams({grant_type:\"authorization_code\",code:query_params,redirect_uri:storedState,client_id:queryParamState,code_verifier});storedState=localStorage.getItem(\"oauth2_token_endpoint\")||\"\";fetch(storedState,{method:\"POST\",headers:new Headers({\"Content-Type\":\"application/x-www-form-urlencoded\"}),body:query_params,credentials:\"include\"});window.close()}else console.log(\"No code or state in query params\")};\nexports.registerOAuth2Worker=async function(){await navigator.serviceWorker.register(\"/oauth-service-worker.js\").then(()=>{console.log(\"Service worker registered\");!navigator.serviceWorker.controller&&location.reload()}).catch(error=>console.log(\"Service worker registration failed: \",error))}}","~:source","shadow$provide[\"module$node_modules$$juxt$pass$dist$juxt_pass_cjs_dev\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// Generate a secure random string using the browser crypto functions\nfunction generateRandomString() {\n  const array = new Uint32Array(14);\n  self.crypto.getRandomValues(array);\n  return Array.from(array, dec => (\"0\" + dec.toString(16)).substring(-2)).join(\"\");\n}\n\n// Calculate the SHA256 hash of the input text.\n// Returns a promise that resolves to an ArrayBuffer\nfunction sha256(plain) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(plain);\n  return self.crypto.subtle.digest(\"SHA-256\", data);\n}\n\n// Base64-urlencodes the input string\nfunction base64UrlEncode(str) {\n  let bytes = Array.from(new Uint8Array(str));\n  let base64 = window.btoa(String.fromCharCode.apply(null, bytes));\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\n\n// Return the base64-urlencoded sha256 hash for the PKCE\n// challenge\nasync function pkceChallengeFromVerifier(v) {\n  const hashed = await sha256(v);\n  return base64UrlEncode(hashed);\n}\n\nasync function authorizationCodeRequestInfo({\n  authorization_endpoint,\n  client_id,\n  redirect_uri,\n  requested_scopes\n}) {\n  const state = generateRandomString();\n  const code_verifier = generateRandomString();\n  const code_challenge = await pkceChallengeFromVerifier(code_verifier);\n  const query_params = new URLSearchParams({\n    response_type: \"code\",\n    client_id,\n    state,\n    redirect_uri,\n    code_challenge,\n    code_challenge_method: \"S256\",\n    ...(requested_scopes && requested_scopes.length && {\n      scope: requested_scopes.join(\" \")\n    })\n  });\n  return {\n    url: `${authorization_endpoint}?${query_params.toString()}`,\n    state,\n    code_verifier\n  };\n}\nasync function postMessageToWorker(obj) {\n  const registration = await navigator.serviceWorker.ready;\n  const serviceWorker = registration.active;\n  serviceWorker?.postMessage(obj);\n}\nfunction exchangeCodeForAccessToken({\n  query_params\n}) {\n  const storedState = localStorage.getItem(\"pkce_state\");\n  const queryParamState = query_params.get(\"state\");\n  const code = query_params.get(\"code\");\n  if (!code || !queryParamState) {\n    console.log(\"No code or state in query params\");\n    return;\n  }\n  if (storedState !== queryParamState) {\n    throw new Error(\"exchangeCodeForAccessToken mismatch between stored state and query param state\");\n  }\n  const redirect_uri = localStorage.getItem(\"oauth2_redirect_uri\") || \"\";\n  const client_id = localStorage.getItem(\"oauth2_client_id\") || \"\";\n  const code_verifier = localStorage.getItem(\"pkce_code_verifier\") || \"\";\n  const payload_params = new URLSearchParams({\n    grant_type: \"authorization_code\",\n    code: code,\n    redirect_uri: redirect_uri,\n    client_id: client_id,\n    code_verifier: code_verifier\n  });\n  const token_endpoint = localStorage.getItem(\"oauth2_token_endpoint\") || \"\";\n  fetch(token_endpoint, {\n    method: \"POST\",\n    headers: new Headers({\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    }),\n    body: payload_params,\n    credentials: \"include\"\n  });\n  window.close();\n}\nasync function authorize(config) {\n  // store config in service worker\n  postMessageToWorker({\n    type: \"storeConfig\",\n    config\n  });\n  const {\n    url,\n    state,\n    code_verifier\n  } = await authorizationCodeRequestInfo(config);\n  localStorage.setItem(\"pkce_state\", state);\n  localStorage.setItem(\"pkce_code_verifier\", code_verifier);\n  localStorage.setItem(\"oauth2_client_id\", config.client_id);\n  localStorage.setItem(\"oauth2_token_endpoint\", config.token_endpoint);\n  localStorage.setItem(\"oauth2_redirect_uri\", config.redirect_uri);\n  window.open(url);\n}\nasync function registerOAuth2Worker() {\n  await navigator.serviceWorker.register(\"/oauth-service-worker.js\").then(() => {\n    console.log(\"Service worker registered\");\n    // we need this as a workaround to the fact that the service worker doesn't kick in with a hard refresh\n    !navigator.serviceWorker.controller && location.reload();\n  }).catch(error => console.log(\"Service worker registration failed: \", error));\n}\n\nexports.authorize = authorize;\nexports.exchangeCodeForAccessToken = exchangeCodeForAccessToken;\nexports.registerOAuth2Worker = registerOAuth2Worker;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["authorize","registerOAuth2Worker","grant_type","url","body","config","code_verifier","method","__esModule","code_challenge_method","value","response_type","scope","type","state","code_challenge","exchangeCodeForAccessToken","redirect_uri","credentials","code","client_id","headers"]],"~:compiled-at",1693990012362,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$juxt$pass$dist$juxt_pass_cjs_dev.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@juxt/pass/dist/juxt-pass.cjs.dev.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$juxt$pass$dist$juxt_pass_cjs_dev\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\n// Generate a secure random string using the browser crypto functions\\nfunction generateRandomString() {\\n  const array = new Uint32Array(14);\\n  self.crypto.getRandomValues(array);\\n  return Array.from(array, dec => (\\\"0\\\" + dec.toString(16)).substring(-2)).join(\\\"\\\");\\n}\\n\\n// Calculate the SHA256 hash of the input text.\\n// Returns a promise that resolves to an ArrayBuffer\\nfunction sha256(plain) {\\n  const encoder = new TextEncoder();\\n  const data = encoder.encode(plain);\\n  return self.crypto.subtle.digest(\\\"SHA-256\\\", data);\\n}\\n\\n// Base64-urlencodes the input string\\nfunction base64UrlEncode(str) {\\n  let bytes = Array.from(new Uint8Array(str));\\n  let base64 = window.btoa(String.fromCharCode.apply(null, bytes));\\n  return base64.replace(/\\\\+/g, \\\"-\\\").replace(/\\\\//g, \\\"_\\\").replace(/=+$/, \\\"\\\");\\n}\\n\\n// Return the base64-urlencoded sha256 hash for the PKCE\\n// challenge\\nasync function pkceChallengeFromVerifier(v) {\\n  const hashed = await sha256(v);\\n  return base64UrlEncode(hashed);\\n}\\n\\nasync function authorizationCodeRequestInfo({\\n  authorization_endpoint,\\n  client_id,\\n  redirect_uri,\\n  requested_scopes\\n}) {\\n  const state = generateRandomString();\\n  const code_verifier = generateRandomString();\\n  const code_challenge = await pkceChallengeFromVerifier(code_verifier);\\n  const query_params = new URLSearchParams({\\n    response_type: \\\"code\\\",\\n    client_id,\\n    state,\\n    redirect_uri,\\n    code_challenge,\\n    code_challenge_method: \\\"S256\\\",\\n    ...(requested_scopes && requested_scopes.length && {\\n      scope: requested_scopes.join(\\\" \\\")\\n    })\\n  });\\n  return {\\n    url: `${authorization_endpoint}?${query_params.toString()}`,\\n    state,\\n    code_verifier\\n  };\\n}\\nasync function postMessageToWorker(obj) {\\n  const registration = await navigator.serviceWorker.ready;\\n  const serviceWorker = registration.active;\\n  serviceWorker?.postMessage(obj);\\n}\\nfunction exchangeCodeForAccessToken({\\n  query_params\\n}) {\\n  const storedState = localStorage.getItem(\\\"pkce_state\\\");\\n  const queryParamState = query_params.get(\\\"state\\\");\\n  const code = query_params.get(\\\"code\\\");\\n  if (!code || !queryParamState) {\\n    console.log(\\\"No code or state in query params\\\");\\n    return;\\n  }\\n  if (storedState !== queryParamState) {\\n    throw new Error(\\\"exchangeCodeForAccessToken mismatch between stored state and query param state\\\");\\n  }\\n  const redirect_uri = localStorage.getItem(\\\"oauth2_redirect_uri\\\") || \\\"\\\";\\n  const client_id = localStorage.getItem(\\\"oauth2_client_id\\\") || \\\"\\\";\\n  const code_verifier = localStorage.getItem(\\\"pkce_code_verifier\\\") || \\\"\\\";\\n  const payload_params = new URLSearchParams({\\n    grant_type: \\\"authorization_code\\\",\\n    code: code,\\n    redirect_uri: redirect_uri,\\n    client_id: client_id,\\n    code_verifier: code_verifier\\n  });\\n  const token_endpoint = localStorage.getItem(\\\"oauth2_token_endpoint\\\") || \\\"\\\";\\n  fetch(token_endpoint, {\\n    method: \\\"POST\\\",\\n    headers: new Headers({\\n      \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded\\\"\\n    }),\\n    body: payload_params,\\n    credentials: \\\"include\\\"\\n  });\\n  window.close();\\n}\\nasync function authorize(config) {\\n  // store config in service worker\\n  postMessageToWorker({\\n    type: \\\"storeConfig\\\",\\n    config\\n  });\\n  const {\\n    url,\\n    state,\\n    code_verifier\\n  } = await authorizationCodeRequestInfo(config);\\n  localStorage.setItem(\\\"pkce_state\\\", state);\\n  localStorage.setItem(\\\"pkce_code_verifier\\\", code_verifier);\\n  localStorage.setItem(\\\"oauth2_client_id\\\", config.client_id);\\n  localStorage.setItem(\\\"oauth2_token_endpoint\\\", config.token_endpoint);\\n  localStorage.setItem(\\\"oauth2_redirect_uri\\\", config.redirect_uri);\\n  window.open(url);\\n}\\nasync function registerOAuth2Worker() {\\n  await navigator.serviceWorker.register(\\\"/oauth-service-worker.js\\\").then(() => {\\n    console.log(\\\"Service worker registered\\\");\\n    // we need this as a workaround to the fact that the service worker doesn't kick in with a hard refresh\\n    !navigator.serviceWorker.controller && location.reload();\\n  }).catch(error => console.log(\\\"Service worker registration failed: \\\", error));\\n}\\n\\nexports.authorize = authorize;\\nexports.exchangeCodeForAccessToken = exchangeCodeForAccessToken;\\nexports.registerOAuth2Worker = registerOAuth2Worker;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"generateRandomString\",\"array\",\"Uint32Array\",\"self\",\"crypto\",\"getRandomValues\",\"Array\",\"from\",\"dec\",\"substring\",\"toString\",\"join\",\"pkceChallengeFromVerifier\",\"v\",\"data\",\"encode\",\"encoder\",\"TextEncoder\",\"hashed\",\"subtle\",\"digest\",\"bytes\",\"Uint8Array\",\"window\",\"btoa\",\"base64\",\"String\",\"fromCharCode\",\"apply\",\"replace\",\"authorizationCodeRequestInfo\",\"authorization_endpoint\",\"client_id\",\"redirect_uri\",\"requested_scopes\",\"state\",\"code_verifier\",\"code_challenge\",\"query_params\",\"URLSearchParams\",\"response_type\",\"code_challenge_method\",\"length\",\"scope\",\"url\",\"postMessageToWorker\",\"obj\",\"active\",\"registration\",\"navigator\",\"serviceWorker\",\"ready\",\"postMessage\",\"Object\",\"defineProperty\",\"value\",\"authorize\",\"config\",\"type\",\"localStorage\",\"setItem\",\"token_endpoint\",\"open\",\"exchangeCodeForAccessToken\",\"storedState\",\"getItem\",\"queryParamState\",\"get\",\"code\",\"Error\",\"payload_params\",\"grant_type\",\"fetch\",\"method\",\"headers\",\"Headers\",\"body\",\"credentials\",\"close\",\"console\",\"log\",\"registerOAuth2Worker\",\"register\",\"then\",\"controller\",\"location\",\"reload\",\"catch\",\"error\"]\n}\n"]