["^ ","~:output",["^ ","~:js","goog.provide('shadow.grove.db');\nshadow.grove.db.make_ident = (function shadow$grove$db$make_ident(type,id){\nreturn shadow.grove.db.ident.__GT_Ident(type,id,null);\n});\nshadow.grove.db.ident_QMARK_ = (function shadow$grove$db$ident_QMARK_(thing){\nreturn shadow.grove.db.ident.ident_QMARK_(thing);\n});\nshadow.grove.db.ident_key = (function shadow$grove$db$ident_key(thing){\nif(shadow.grove.db.ident.ident_QMARK_(thing)){\n} else {\nthrow (new Error(\"Assert failed: (ident/ident? thing)\"));\n}\n\nreturn thing.entity_type;\n});\nshadow.grove.db.ident_val = (function shadow$grove$db$ident_val(thing){\nif(shadow.grove.db.ident.ident_QMARK_(thing)){\n} else {\nthrow (new Error(\"Assert failed: (ident/ident? thing)\"));\n}\n\nreturn thing.id;\n});\nshadow.grove.db.ident_as_vec = (function shadow$grove$db$ident_as_vec(ident){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [shadow.grove.db.ident_key(ident),shadow.grove.db.ident_val(ident)], null);\n});\nshadow.grove.db.parse_joins = (function shadow$grove$db$parse_joins(spec,joins){\nreturn cljs.core.reduce_kv((function (spec__$1,attr,val){\nif((!(((cljs.core.vector_QMARK_(val)) && (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"one\",\"one\",935007904),cljs.core.first(val))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"many\",\"many\",1092119164),cljs.core.first(val))))))))){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"invalid join\",joins);\n} else {\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$5(spec__$1,new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),cljs.core.assoc,attr,cljs.core.second(val));\n}\n}),spec,joins);\n});\nshadow.grove.db.parse_primary_key = (function shadow$grove$db$parse_primary_key(p__12175,p__12176){\nvar map__12177 = p__12175;\nvar map__12177__$1 = cljs.core.__destructure_map(map__12177);\nvar spec = map__12177__$1;\nvar entity_type = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12177__$1,new cljs.core.Keyword(null,\"entity-type\",\"entity-type\",-1957300125));\nvar map__12178 = p__12176;\nvar map__12178__$1 = cljs.core.__destructure_map(map__12178);\nvar config = map__12178__$1;\nvar primary_key = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12178__$1,new cljs.core.Keyword(null,\"primary-key\",\"primary-key\",1422512605));\nif(cljs.core.truth_((function (){var and__5043__auto__ = cljs.core.not(primary_key);\nif(and__5043__auto__){\nreturn new cljs.core.Keyword(null,\"ident-gen\",\"ident-gen\",872410869).cljs$core$IFn$_invoke$arity$1(config);\n} else {\nreturn and__5043__auto__;\n}\n})())){\nreturn spec;\n} else {\nif((primary_key instanceof cljs.core.Keyword)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(spec,new cljs.core.Keyword(null,\"ident-gen\",\"ident-gen\",872410869),(function (p1__12173_SHARP_){\nreturn shadow.grove.db.make_ident(entity_type,cljs.core.get.cljs$core$IFn$_invoke$arity$2(p1__12173_SHARP_,primary_key));\n}));\n} else {\nif(((cljs.core.vector_QMARK_(primary_key)) && (cljs.core.every_QMARK_(cljs.core.keyword_QMARK_,primary_key)))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(spec,new cljs.core.Keyword(null,\"ident-gen\",\"ident-gen\",872410869),(function (item){\nreturn shadow.grove.db.make_ident(entity_type,cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__12174_SHARP_){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(item,p1__12174_SHARP_);\n}),primary_key));\n}));\n} else {\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"invalid :primary-key\",config);\n\n}\n}\n}\n});\nshadow.grove.db.parse_entity_spec = (function shadow$grove$db$parse_entity_spec(entity_type,p__12183){\nvar map__12184 = p__12183;\nvar map__12184__$1 = cljs.core.__destructure_map(map__12184);\nvar config = map__12184__$1;\nvar joins = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12184__$1,new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699));\nif((entity_type instanceof cljs.core.Keyword)){\n} else {\nthrow (new Error(\"Assert failed: (keyword? entity-type)\"));\n}\n\nreturn shadow.grove.db.parse_joins(shadow.grove.db.parse_primary_key(cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(config,new cljs.core.Keyword(null,\"entity-type\",\"entity-type\",-1957300125),entity_type,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),cljs.core.PersistentArrayMap.EMPTY], 0)),config),joins);\n});\nshadow.grove.db.parse_schema = (function shadow$grove$db$parse_schema(spec){\nreturn cljs.core.reduce_kv((function (schema,key,p__12190){\nvar map__12191 = p__12190;\nvar map__12191__$1 = cljs.core.__destructure_map(map__12191);\nvar config = map__12191__$1;\nvar type = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12191__$1,new cljs.core.Keyword(null,\"type\",\"type\",1174270348));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"entity\",\"entity\",-450970276),type)){\nreturn cljs.core.assoc_in(schema,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"entities\",\"entities\",1940967403),key], null),shadow.grove.db.parse_entity_spec(key,config));\n} else {\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"unknown type\",new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"key\",\"key\",-1516042587),key,new cljs.core.Keyword(null,\"config\",\"config\",994861415),config], null));\n\n}\n}),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"entities\",\"entities\",1940967403),cljs.core.PersistentArrayMap.EMPTY], null),spec);\n});\nshadow.grove.db.nav_fn = (function shadow$grove$db$nav_fn(db,key,val){\nif(shadow.grove.db.ident_QMARK_(val)){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(db,val);\n} else {\nif(cljs.core.coll_QMARK_(val)){\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4(val,cljs.core.assoc,new cljs.core.Symbol(\"clojure.core.protocols\",\"datafy\",\"clojure.core.protocols/datafy\",707534751,null),(function (m){\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4(m,cljs.core.assoc,new cljs.core.Symbol(\"clojure.core.protocols\",\"nav\",\"clojure.core.protocols/nav\",298936762,null),(function (m__$1,key__$1,val__$1){\nif(shadow.grove.db.ident_QMARK_(val__$1)){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(db,val__$1);\n} else {\nreturn val__$1;\n}\n}));\n}));\n} else {\nreturn val;\n\n}\n}\n});\nshadow.grove.db.configure = (function shadow$grove$db$configure(init_db,spec){\nvar schema = shadow.grove.db.parse_schema(spec);\nvar m = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(\"shadow.grove.db\",\"schema\",\"shadow.grove.db/schema\",1093729226),schema,new cljs.core.Keyword(\"shadow.grove.db\",\"ident-types\",\"shadow.grove.db/ident-types\",-1275004257),cljs.core.set(cljs.core.keys(new cljs.core.Keyword(null,\"entities\",\"entities\",1940967403).cljs$core$IFn$_invoke$arity$1(schema))),new cljs.core.Symbol(\"clojure.core.protocols\",\"nav\",\"clojure.core.protocols/nav\",298936762,null),shadow.grove.db.nav_fn], null);\nreturn cljs.core.with_meta(init_db,m);\n});\nshadow.grove.db.coll_key = (function shadow$grove$db$coll_key(thing){\nif(shadow.grove.db.ident_QMARK_(thing)){\n} else {\nthrow (new Error(\"Assert failed: (ident? thing)\"));\n}\n\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"shadow.grove.db\",\"all\",\"shadow.grove.db/all\",-709808235),shadow.grove.db.ident_key(thing)], null);\n});\nshadow.grove.db.normalize_STAR_ = (function shadow$grove$db$normalize_STAR_(imports,schema,entity_type,item){\nvar map__12195 = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(schema,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"entities\",\"entities\",1940967403),entity_type], null));\nvar map__12195__$1 = cljs.core.__destructure_map(map__12195);\nvar ent_config = map__12195__$1;\nvar ident_gen = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12195__$1,new cljs.core.Keyword(null,\"ident-gen\",\"ident-gen\",872410869));\nvar id_pred = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12195__$1,new cljs.core.Keyword(null,\"id-pred\",\"id-pred\",-1220295264));\nvar joins = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12195__$1,new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699));\nvar item_ident = cljs.core.get.cljs$core$IFn$_invoke$arity$2(item,new cljs.core.Keyword(\"db\",\"ident\",\"db/ident\",-737096));\nvar ident = (ident_gen.cljs$core$IFn$_invoke$arity$1 ? ident_gen.cljs$core$IFn$_invoke$arity$1(item) : ident_gen.call(null,item));\nvar _ = (cljs.core.truth_((function (){var and__5043__auto__ = item_ident;\nif(cljs.core.truth_(and__5043__auto__)){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(item_ident,ident);\n} else {\nreturn and__5043__auto__;\n}\n})())?(function(){throw cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"item contained ident but we generated a different one\",new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"item\",\"item\",249373802),item,new cljs.core.Keyword(null,\"ident\",\"ident\",-742346),ident], null))})():null);\nvar item__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(item_ident,ident))?item:cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(item,new cljs.core.Keyword(\"db\",\"ident\",\"db/ident\",-737096),ident));\nvar item__$2 = cljs.core.reduce_kv((function (item__$2,key,join_type){\nvar curr_val = cljs.core.get.cljs$core$IFn$_invoke$arity$3(item__$2,key,new cljs.core.Keyword(\"shadow.grove.db\",\"skip\",\"shadow.grove.db/skip\",-1016607174));\nvar norm_val = ((cljs.core.keyword_identical_QMARK_(new cljs.core.Keyword(\"shadow.grove.db\",\"skip\",\"shadow.grove.db/skip\",-1016607174),curr_val))?curr_val:((shadow.grove.db.ident_QMARK_(curr_val))?new cljs.core.Keyword(\"shadow.grove.db\",\"skip\",\"shadow.grove.db/skip\",-1016607174):((cljs.core.map_QMARK_(curr_val))?(shadow.grove.db.normalize_STAR_.cljs$core$IFn$_invoke$arity$4 ? shadow.grove.db.normalize_STAR_.cljs$core$IFn$_invoke$arity$4(imports,schema,join_type,curr_val) : shadow.grove.db.normalize_STAR_.call(null,imports,schema,join_type,curr_val)):((cljs.core.vector_QMARK_(curr_val))?cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__12194_SHARP_){\nreturn (shadow.grove.db.normalize_STAR_.cljs$core$IFn$_invoke$arity$4 ? shadow.grove.db.normalize_STAR_.cljs$core$IFn$_invoke$arity$4(imports,schema,join_type,p1__12194_SHARP_) : shadow.grove.db.normalize_STAR_.call(null,imports,schema,join_type,p1__12194_SHARP_));\n}),curr_val):(((!((curr_val == null))))?shadow.grove.db.make_ident(join_type,curr_val):(function(){throw cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"unexpected value in join attr\",new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"item\",\"item\",249373802),item__$2,new cljs.core.Keyword(null,\"key\",\"key\",-1516042587),key,new cljs.core.Keyword(null,\"val\",\"val\",128701612),curr_val,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type], null))})()\n)))));\nif(cljs.core.keyword_identical_QMARK_(norm_val,new cljs.core.Keyword(\"shadow.grove.db\",\"skip\",\"shadow.grove.db/skip\",-1016607174))){\nreturn item__$2;\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(item__$2,key,norm_val);\n}\n}),item__$1,joins);\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(imports,cljs.core.conj,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [ident,item__$2], null));\n\nreturn ident;\n});\n/**\n * returns a seq of [[ident item] ...] tuples\n */\nshadow.grove.db.normalize = (function shadow$grove$db$normalize(schema,entity_type,vals){\nvar imports = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentVector.EMPTY);\nif(cljs.core.map_QMARK_(vals)){\nshadow.grove.db.normalize_STAR_(imports,schema,entity_type,vals);\n} else {\nif(cljs.core.sequential_QMARK_(vals)){\nvar seq__12202_12487 = cljs.core.seq(vals);\nvar chunk__12203_12488 = null;\nvar count__12204_12489 = (0);\nvar i__12205_12490 = (0);\nwhile(true){\nif((i__12205_12490 < count__12204_12489)){\nvar item_12491 = chunk__12203_12488.cljs$core$IIndexed$_nth$arity$2(null,i__12205_12490);\nshadow.grove.db.normalize_STAR_(imports,schema,entity_type,item_12491);\n\n\nvar G__12492 = seq__12202_12487;\nvar G__12493 = chunk__12203_12488;\nvar G__12494 = count__12204_12489;\nvar G__12495 = (i__12205_12490 + (1));\nseq__12202_12487 = G__12492;\nchunk__12203_12488 = G__12493;\ncount__12204_12489 = G__12494;\ni__12205_12490 = G__12495;\ncontinue;\n} else {\nvar temp__5804__auto___12496 = cljs.core.seq(seq__12202_12487);\nif(temp__5804__auto___12496){\nvar seq__12202_12497__$1 = temp__5804__auto___12496;\nif(cljs.core.chunked_seq_QMARK_(seq__12202_12497__$1)){\nvar c__5568__auto___12498 = cljs.core.chunk_first(seq__12202_12497__$1);\nvar G__12499 = cljs.core.chunk_rest(seq__12202_12497__$1);\nvar G__12500 = c__5568__auto___12498;\nvar G__12501 = cljs.core.count(c__5568__auto___12498);\nvar G__12502 = (0);\nseq__12202_12487 = G__12499;\nchunk__12203_12488 = G__12500;\ncount__12204_12489 = G__12501;\ni__12205_12490 = G__12502;\ncontinue;\n} else {\nvar item_12503 = cljs.core.first(seq__12202_12497__$1);\nshadow.grove.db.normalize_STAR_(imports,schema,entity_type,item_12503);\n\n\nvar G__12504 = cljs.core.next(seq__12202_12497__$1);\nvar G__12505 = null;\nvar G__12506 = (0);\nvar G__12507 = (0);\nseq__12202_12487 = G__12504;\nchunk__12203_12488 = G__12505;\ncount__12204_12489 = G__12506;\ni__12205_12490 = G__12507;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n} else {\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"cannot import\",new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"entity-type\",\"entity-type\",-1957300125),entity_type,new cljs.core.Keyword(null,\"vals\",\"vals\",768058733),vals], null));\n\n}\n}\n\nreturn cljs.core.deref(imports);\n});\nshadow.grove.db.set_conj = (function shadow$grove$db$set_conj(x,y){\nif((x == null)){\nreturn cljs.core.PersistentHashSet.createAsIfByAssoc([y]);\n} else {\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(x,y);\n}\n});\nshadow.grove.db.merge_or_replace = (function shadow$grove$db$merge_or_replace(left,right){\nif(cljs.core.keyword_identical_QMARK_(new cljs.core.Keyword(\"db\",\"loading\",\"db/loading\",-737049547),left)){\nreturn right;\n} else {\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([left,right], 0));\n}\n});\nshadow.grove.db.merge_imports = (function shadow$grove$db$merge_imports(data,imports){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (data__$1,p__12222){\nvar vec__12223 = p__12222;\nvar ident = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__12223,(0),null);\nvar item = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__12223,(1),null);\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(data__$1,ident,shadow.grove.db.merge_or_replace,item);\n}),data,imports);\n});\nshadow.grove.db.merge_seq = (function shadow$grove$db$merge_seq(var_args){\nvar G__12235 = arguments.length;\nswitch (G__12235) {\ncase 3:\nreturn shadow.grove.db.merge_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn shadow.grove.db.merge_seq.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(shadow.grove.db.merge_seq.cljs$core$IFn$_invoke$arity$3 = (function (data,entity_type,coll){\nreturn shadow.grove.db.merge_seq.cljs$core$IFn$_invoke$arity$4(data,entity_type,coll,null);\n}));\n\n(shadow.grove.db.merge_seq.cljs$core$IFn$_invoke$arity$4 = (function (data,entity_type,coll,target_path_or_fn){\nif(cljs.core.sequential_QMARK_(coll)){\n} else {\nthrow (new Error(\"Assert failed: (sequential? coll)\"));\n}\n\nvar map__12245 = cljs.core.meta(data);\nvar map__12245__$1 = cljs.core.__destructure_map(map__12245);\nvar schema = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12245__$1,new cljs.core.Keyword(\"shadow.grove.db\",\"schema\",\"shadow.grove.db/schema\",1093729226));\nvar _ = (cljs.core.truth_(schema)?null:(function(){throw cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"data missing schema\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"data\",\"data\",-232669377),data], null))})());\nvar map__12246 = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(schema,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"entities\",\"entities\",1940967403),entity_type], null));\nvar map__12246__$1 = cljs.core.__destructure_map(map__12246);\nvar entity_spec = map__12246__$1;\nvar ident_gen = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12246__$1,new cljs.core.Keyword(null,\"ident-gen\",\"ident-gen\",872410869));\nvar ___$1 = (cljs.core.truth_(entity_spec)?null:(function(){throw cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"entity not defined\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"entity-type\",\"entity-type\",-1957300125),entity_type], null))})());\nvar idents = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$2(ident_gen,coll));\nvar imports = shadow.grove.db.normalize(schema,entity_type,coll);\nvar G__12247 = shadow.grove.db.merge_imports(data,imports);\nvar G__12247__$1 = ((cljs.core.vector_QMARK_(target_path_or_fn))?cljs.core.assoc_in(G__12247,target_path_or_fn,idents):G__12247);\nif(cljs.core.fn_QMARK_(target_path_or_fn)){\nreturn (target_path_or_fn.cljs$core$IFn$_invoke$arity$2 ? target_path_or_fn.cljs$core$IFn$_invoke$arity$2(G__12247__$1,idents) : target_path_or_fn.call(null,G__12247__$1,idents));\n} else {\nreturn G__12247__$1;\n}\n}));\n\n(shadow.grove.db.merge_seq.cljs$lang$maxFixedArity = 4);\n\nshadow.grove.db.add = (function shadow$grove$db$add(var_args){\nvar G__12250 = arguments.length;\nswitch (G__12250) {\ncase 3:\nreturn shadow.grove.db.add.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn shadow.grove.db.add.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(shadow.grove.db.add.cljs$core$IFn$_invoke$arity$3 = (function (data,entity_type,item){\nreturn shadow.grove.db.add.cljs$core$IFn$_invoke$arity$4(data,entity_type,item,null);\n}));\n\n(shadow.grove.db.add.cljs$core$IFn$_invoke$arity$4 = (function (data,entity_type,item,target_path){\nif(cljs.core.map_QMARK_(item)){\n} else {\nthrow (new Error(\"Assert failed: (map? item)\"));\n}\n\nvar map__12254 = cljs.core.meta(data);\nvar map__12254__$1 = cljs.core.__destructure_map(map__12254);\nvar schema = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12254__$1,new cljs.core.Keyword(\"shadow.grove.db\",\"schema\",\"shadow.grove.db/schema\",1093729226));\nvar _ = (cljs.core.truth_(schema)?null:(function(){throw cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"data missing schema\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"data\",\"data\",-232669377),data], null))})());\nvar map__12255 = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(schema,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"entities\",\"entities\",1940967403),entity_type], null));\nvar map__12255__$1 = cljs.core.__destructure_map(map__12255);\nvar entity_spec = map__12255__$1;\nvar ident_gen = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12255__$1,new cljs.core.Keyword(null,\"ident-gen\",\"ident-gen\",872410869));\nvar ___$1 = (cljs.core.truth_(entity_spec)?null:(function(){throw cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"entity not defined\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"entity-type\",\"entity-type\",-1957300125),entity_type], null))})());\nvar ident = (ident_gen.cljs$core$IFn$_invoke$arity$1 ? ident_gen.cljs$core$IFn$_invoke$arity$1(item) : ident_gen.call(null,item));\nvar imports = shadow.grove.db.normalize(schema,entity_type,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [item], null));\nvar G__12256 = shadow.grove.db.merge_imports(data,imports);\nif(cljs.core.truth_(target_path)){\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$4(G__12256,target_path,cljs.core.conj,ident);\n} else {\nreturn G__12256;\n}\n}));\n\n(shadow.grove.db.add.cljs$lang$maxFixedArity = 4);\n\nshadow.grove.db.update_entity = (function shadow$grove$db$update_entity(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___12529 = arguments.length;\nvar i__5770__auto___12530 = (0);\nwhile(true){\nif((i__5770__auto___12530 < len__5769__auto___12529)){\nargs__5775__auto__.push((arguments[i__5770__auto___12530]));\n\nvar G__12531 = (i__5770__auto___12530 + (1));\ni__5770__auto___12530 = G__12531;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((4) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((4)),(0),null)):null);\nreturn shadow.grove.db.update_entity.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__5776__auto__);\n});\n\n(shadow.grove.db.update_entity.cljs$core$IFn$_invoke$arity$variadic = (function (data,entity_type,id,update_fn,args){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(data,shadow.grove.db.make_ident(entity_type,id),(function (p1__12265_SHARP_){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(update_fn,p1__12265_SHARP_,args);\n}));\n}));\n\n(shadow.grove.db.update_entity.cljs$lang$maxFixedArity = (4));\n\n/** @this {Function} */\n(shadow.grove.db.update_entity.cljs$lang$applyTo = (function (seq12266){\nvar G__12267 = cljs.core.first(seq12266);\nvar seq12266__$1 = cljs.core.next(seq12266);\nvar G__12268 = cljs.core.first(seq12266__$1);\nvar seq12266__$2 = cljs.core.next(seq12266__$1);\nvar G__12269 = cljs.core.first(seq12266__$2);\nvar seq12266__$3 = cljs.core.next(seq12266__$2);\nvar G__12270 = cljs.core.first(seq12266__$3);\nvar seq12266__$4 = cljs.core.next(seq12266__$3);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__12267,G__12268,G__12269,G__12270,seq12266__$4);\n}));\n\nshadow.grove.db.all_idents_of = (function shadow$grove$db$all_idents_of(db,entity_type){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(db,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"shadow.grove.db\",\"all\",\"shadow.grove.db/all\",-709808235),entity_type], null));\n});\nshadow.grove.db.all_of = (function shadow$grove$db$all_of(db,entity_type){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__12286_SHARP_){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(db,p1__12286_SHARP_);\n}),shadow.grove.db.all_idents_of(db,entity_type));\n});\nshadow.grove.db.remove = (function shadow$grove$db$remove(data,thing){\nif(shadow.grove.db.ident_QMARK_(thing)){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(data,thing);\n} else {\nif(cljs.core.truth_((function (){var and__5043__auto__ = cljs.core.map_QMARK_(thing);\nif(and__5043__auto__){\nreturn new cljs.core.Keyword(\"db\",\"ident\",\"db/ident\",-737096).cljs$core$IFn$_invoke$arity$1(thing);\n} else {\nreturn and__5043__auto__;\n}\n})())){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(data,new cljs.core.Keyword(\"db\",\"ident\",\"db/ident\",-737096).cljs$core$IFn$_invoke$arity$1(thing));\n} else {\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"don't know how to remove thing\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"thing\",\"thing\",270525715),thing], null));\n\n}\n}\n});\nshadow.grove.db.remove_idents = (function shadow$grove$db$remove_idents(data,idents){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(shadow.grove.db.remove,data,idents);\n});\n\n/**\n * @interface\n */\nshadow.grove.db.IObserved = function(){};\n\nvar shadow$grove$db$IObserved$observed_keys$dyn_12532 = (function (this$){\nvar x__5393__auto__ = (((this$ == null))?null:this$);\nvar m__5394__auto__ = (shadow.grove.db.observed_keys[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ == null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5394__auto__.call(null,this$));\n} else {\nvar m__5392__auto__ = (shadow.grove.db.observed_keys[\"_\"]);\nif((!((m__5392__auto__ == null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5392__auto__.call(null,this$));\n} else {\nthrow cljs.core.missing_protocol(\"IObserved.observed-keys\",this$);\n}\n}\n});\nshadow.grove.db.observed_keys = (function shadow$grove$db$observed_keys(this$){\nif((((!((this$ == null)))) && ((!((this$.shadow$grove$db$IObserved$observed_keys$arity$1 == null)))))){\nreturn this$.shadow$grove$db$IObserved$observed_keys$arity$1(this$);\n} else {\nreturn shadow$grove$db$IObserved$observed_keys$dyn_12532(this$);\n}\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {shadow.grove.db.IObserved}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\nshadow.grove.db.ObservedData = (function (keys_used,data){\nthis.keys_used = keys_used;\nthis.data = data;\nthis.cljs$lang$protocol_mask$partition0$ = 132864;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\n(shadow.grove.db.ObservedData.prototype.shadow$grove$db$IObserved$ = cljs.core.PROTOCOL_SENTINEL);\n\n(shadow.grove.db.ObservedData.prototype.shadow$grove$db$IObserved$observed_keys$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.persistent_BANG_(self__.keys_used);\n}));\n\n(shadow.grove.db.ObservedData.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.data.cljs$core$IMeta$_meta$arity$1(null);\n}));\n\n(shadow.grove.db.ObservedData.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"observed data is read-only\",cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(shadow.grove.db.ObservedData.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.data.cljs$core$IAssociative$_contains_key_QMARK_$arity$2(null,k);\n}));\n\n(shadow.grove.db.ObservedData.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (coll,k,v){\nvar self__ = this;\nvar coll__$1 = this;\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"observed data is read-only, assoc not allowed\",new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"k\",\"k\",-2146297393),k,new cljs.core.Keyword(null,\"v\",\"v\",21465059),v], null));\n}));\n\n(shadow.grove.db.ObservedData.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (_,key){\nvar self__ = this;\nvar ___$1 = this;\nif((key == null)){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"cannot read nil key\",cljs.core.PersistentArrayMap.EMPTY);\n} else {\n}\n\n(self__.keys_used = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(self__.keys_used,key));\n\nreturn self__.data.cljs$core$ILookup$_lookup$arity$2(null,key);\n}));\n\n(shadow.grove.db.ObservedData.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (_,key,default$){\nvar self__ = this;\nvar ___$1 = this;\nif((key == null)){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"cannot read nil key\",cljs.core.PersistentArrayMap.EMPTY);\n} else {\n}\n\n(self__.keys_used = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(self__.keys_used,key));\n\nreturn self__.data.cljs$core$ILookup$_lookup$arity$3(null,key,default$);\n}));\n\n(shadow.grove.db.ObservedData.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"keys-used\",\"keys-used\",-35184854,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"data\",\"data\",1407862150,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223),new cljs.core.Symbol(null,\"not-native\",\"not-native\",-236392494,null)], null))], null);\n}));\n\n(shadow.grove.db.ObservedData.cljs$lang$type = true);\n\n(shadow.grove.db.ObservedData.cljs$lang$ctorStr = \"shadow.grove.db/ObservedData\");\n\n(shadow.grove.db.ObservedData.cljs$lang$ctorPrWriter = (function (this__5330__auto__,writer__5331__auto__,opt__5332__auto__){\nreturn cljs.core._write(writer__5331__auto__,\"shadow.grove.db/ObservedData\");\n}));\n\n/**\n * Positional factory function for shadow.grove.db/ObservedData.\n */\nshadow.grove.db.__GT_ObservedData = (function shadow$grove$db$__GT_ObservedData(keys_used,data){\nreturn (new shadow.grove.db.ObservedData(keys_used,data));\n});\n\nshadow.grove.db.observed = (function shadow$grove$db$observed(data){\nreturn (new shadow.grove.db.ObservedData(cljs.core.transient$(cljs.core.PersistentHashSet.EMPTY),data));\n});\n\n/**\n * @interface\n */\nshadow.grove.db.ITxCommit = function(){};\n\nvar shadow$grove$db$ITxCommit$commit_BANG_$dyn_12536 = (function (this$){\nvar x__5393__auto__ = (((this$ == null))?null:this$);\nvar m__5394__auto__ = (shadow.grove.db.commit_BANG_[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ == null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5394__auto__.call(null,this$));\n} else {\nvar m__5392__auto__ = (shadow.grove.db.commit_BANG_[\"_\"]);\nif((!((m__5392__auto__ == null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5392__auto__.call(null,this$));\n} else {\nthrow cljs.core.missing_protocol(\"ITxCommit.commit!\",this$);\n}\n}\n});\nshadow.grove.db.commit_BANG_ = (function shadow$grove$db$commit_BANG_(this$){\nif((((!((this$ == null)))) && ((!((this$.shadow$grove$db$ITxCommit$commit_BANG_$arity$1 == null)))))){\nreturn this$.shadow$grove$db$ITxCommit$commit_BANG_$arity$1(this$);\n} else {\nreturn shadow$grove$db$ITxCommit$commit_BANG_$dyn_12536(this$);\n}\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.ICounted}\n * @implements {shadow.grove.db.ITxCommit}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IDeref}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\nshadow.grove.db.TransactedData = (function (data,keys_new,keys_updated,keys_removed,completed_ref){\nthis.data = data;\nthis.keys_new = keys_new;\nthis.keys_updated = keys_updated;\nthis.keys_removed = keys_removed;\nthis.completed_ref = completed_ref;\nthis.cljs$lang$protocol_mask$partition0$ = 165642;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\n(shadow.grove.db.TransactedData.prototype.check_completed_BANG_ = (function (){\nvar self__ = this;\nvar this$ = this;\nif(cljs.core.truth_(cljs.core.deref(self__.completed_ref))){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"transaction concluded, don't hold on to db while in tx\",cljs.core.PersistentArrayMap.EMPTY);\n} else {\nreturn null;\n}\n}));\n\n(shadow.grove.db.TransactedData.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (this$,key){\nvar self__ = this;\nvar this$__$1 = this;\nthis$__$1.check_completed_BANG_();\n\nreturn self__.data.cljs$core$ILookup$_lookup$arity$2(null,key);\n}));\n\n(shadow.grove.db.TransactedData.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (this$,key,default$){\nvar self__ = this;\nvar this$__$1 = this;\nthis$__$1.check_completed_BANG_();\n\nreturn self__.data.cljs$core$ILookup$_lookup$arity$3(null,key,default$);\n}));\n\n(shadow.grove.db.TransactedData.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.data.cljs$core$IMeta$_meta$arity$1(null);\n}));\n\n(shadow.grove.db.TransactedData.prototype.cljs$core$ICounted$_count$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nthis$__$1.check_completed_BANG_();\n\nreturn self__.data.cljs$core$ICounted$_count$arity$1(null);\n}));\n\n(shadow.grove.db.TransactedData.prototype.shadow$grove$db$ITxCommit$ = cljs.core.PROTOCOL_SENTINEL);\n\n(shadow.grove.db.TransactedData.prototype.shadow$grove$db$ITxCommit$commit_BANG_$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\ncljs.core.vreset_BANG_(self__.completed_ref,true);\n\nreturn new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"data\",\"data\",-232669377),self__.data,new cljs.core.Keyword(null,\"keys-new\",\"keys-new\",546185618),cljs.core.persistent_BANG_(self__.keys_new),new cljs.core.Keyword(null,\"keys-updated\",\"keys-updated\",1209111301),cljs.core.persistent_BANG_(self__.keys_updated),new cljs.core.Keyword(null,\"keys-removed\",\"keys-removed\",-110314827),cljs.core.persistent_BANG_(self__.keys_removed)], null);\n}));\n\n(shadow.grove.db.TransactedData.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (this$,key){\nvar self__ = this;\nvar this$__$1 = this;\nthis$__$1.check_completed_BANG_();\n\nvar key_is_ident_QMARK_ = shadow.grove.db.ident_QMARK_(key);\nvar next_data = (function (){var G__12392 = self__.data.cljs$core$IMap$_dissoc$arity$2(null,key);\nif(key_is_ident_QMARK_){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(G__12392,shadow.grove.db.coll_key(key),cljs.core.disj,key);\n} else {\nreturn G__12392;\n}\n})();\nvar next_removed = (function (){var G__12396 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(self__.keys_removed,key);\nif(key_is_ident_QMARK_){\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(G__12396,shadow.grove.db.coll_key(key));\n} else {\nreturn G__12396;\n}\n})();\nreturn (new shadow.grove.db.TransactedData(next_data,self__.keys_new,self__.keys_updated,next_removed,self__.completed_ref));\n}));\n\n(shadow.grove.db.TransactedData.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.data.cljs$core$IAssociative$_contains_key_QMARK_$arity$2(null,k);\n}));\n\n(shadow.grove.db.TransactedData.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (this$,key,value){\nvar self__ = this;\nvar this$__$1 = this;\nthis$__$1.check_completed_BANG_();\n\nif((key == null)){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"nil key not allowed\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),value], null));\n} else {\n}\n\nvar prev_val = self__.data.cljs$core$ILookup$_lookup$arity$3(null,key,new cljs.core.Keyword(\"shadow.grove.db\",\"not-found\",\"shadow.grove.db/not-found\",1006210955));\nvar is_ident_update_QMARK_ = ((shadow.grove.db.ident_QMARK_(key)) && (cljs.core.contains_QMARK_(new cljs.core.Keyword(\"shadow.grove.db\",\"ident-types\",\"shadow.grove.db/ident-types\",-1275004257).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(self__.data)),shadow.grove.db.ident_key(key))));\nif((prev_val === value)){\nreturn this$__$1;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"shadow.grove.db\",\"not-found\",\"shadow.grove.db/not-found\",1006210955),prev_val)){\nif((!(is_ident_update_QMARK_))){\nreturn (new shadow.grove.db.TransactedData(self__.data.cljs$core$IAssociative$_assoc$arity$3(null,key,value),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(self__.keys_new,key),self__.keys_updated,self__.keys_removed,self__.completed_ref));\n} else {\nreturn (new shadow.grove.db.TransactedData(cljs.core.update.cljs$core$IFn$_invoke$arity$4(self__.data.cljs$core$IAssociative$_assoc$arity$3(null,key,value),shadow.grove.db.coll_key(key),shadow.grove.db.set_conj,key),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(self__.keys_new,key),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(self__.keys_updated,shadow.grove.db.coll_key(key)),self__.keys_removed,self__.completed_ref));\n}\n} else {\nif((!(is_ident_update_QMARK_))){\nreturn (new shadow.grove.db.TransactedData(self__.data.cljs$core$IAssociative$_assoc$arity$3(null,key,value),self__.keys_new,cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(self__.keys_updated,key),self__.keys_removed,self__.completed_ref));\n} else {\nreturn (new shadow.grove.db.TransactedData(self__.data.cljs$core$IAssociative$_assoc$arity$3(null,key,value),self__.keys_new,cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(self__.keys_updated,key),shadow.grove.db.coll_key(key)),self__.keys_removed,self__.completed_ref));\n}\n}\n}\n}));\n\n(shadow.grove.db.TransactedData.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,entry){\nvar self__ = this;\nvar coll__$1 = this;\nif(cljs.core.vector_QMARK_(entry)){\nreturn coll__$1.cljs$core$IAssociative$_assoc$arity$3(null,entry.cljs$core$IIndexed$_nth$arity$2(null,(0)),entry.cljs$core$IIndexed$_nth$arity$2(null,(1)));\n} else {\nvar ret = coll__$1;\nvar es = cljs.core.seq(entry);\nwhile(true){\nif((es == null)){\nreturn ret;\n} else {\nvar e = cljs.core.first(es);\nif(cljs.core.vector_QMARK_(e)){\nvar G__12550 = cljs.core._assoc(ret,e.cljs$core$IIndexed$_nth$arity$2(null,(0)),e.cljs$core$IIndexed$_nth$arity$2(null,(1)));\nvar G__12551 = cljs.core.next(es);\nret = G__12550;\nes = G__12551;\ncontinue;\n} else {\nthrow (new Error(\"conj on a map takes map entries or seqables of map entries\"));\n}\n}\nbreak;\n}\n}\n}));\n\n(shadow.grove.db.TransactedData.prototype.cljs$core$IDeref$_deref$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.data;\n}));\n\n(shadow.grove.db.TransactedData.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"data\",\"data\",1407862150,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223),new cljs.core.Symbol(null,\"not-native\",\"not-native\",-236392494,null)], null)),new cljs.core.Symbol(null,\"keys-new\",\"keys-new\",-2108250151,null),new cljs.core.Symbol(null,\"keys-updated\",\"keys-updated\",-1445324468,null),new cljs.core.Symbol(null,\"keys-removed\",\"keys-removed\",1530216700,null),new cljs.core.Symbol(null,\"completed-ref\",\"completed-ref\",-1986860423,null)], null);\n}));\n\n(shadow.grove.db.TransactedData.cljs$lang$type = true);\n\n(shadow.grove.db.TransactedData.cljs$lang$ctorStr = \"shadow.grove.db/TransactedData\");\n\n(shadow.grove.db.TransactedData.cljs$lang$ctorPrWriter = (function (this__5330__auto__,writer__5331__auto__,opt__5332__auto__){\nreturn cljs.core._write(writer__5331__auto__,\"shadow.grove.db/TransactedData\");\n}));\n\n/**\n * Positional factory function for shadow.grove.db/TransactedData.\n */\nshadow.grove.db.__GT_TransactedData = (function shadow$grove$db$__GT_TransactedData(data,keys_new,keys_updated,keys_removed,completed_ref){\nreturn (new shadow.grove.db.TransactedData(data,keys_new,keys_updated,keys_removed,completed_ref));\n});\n\nshadow.grove.db.transacted = (function shadow$grove$db$transacted(data){\nreturn (new shadow.grove.db.TransactedData(data,cljs.core.transient$(cljs.core.PersistentHashSet.EMPTY),cljs.core.transient$(cljs.core.PersistentHashSet.EMPTY),cljs.core.transient$(cljs.core.PersistentHashSet.EMPTY),cljs.core.volatile_BANG_(false)));\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","shadow/grove/db.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",20],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",["~$remove","~$ident?"]],"~:name","~$shadow.grove.db","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$shadow.grove.db.ident","^N","~$ident","^N","~$cljs.core","^P","~$goog","^Q"],"~:seen",["^D",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^P","^P"],"~:form",["~#list",["~$ns","^H",["^W",["~:refer-clojure","~:exclude",["^W",["^F","^E"]]]],["^W",["^S",["^N","~:as","^O"]]]]],"~:flags",["^ ","^S",["^D",[]]],"~:js-deps",["^ "],"~:deps",["^Q","^P","^N"]],"^K","^H","~:resource-id",["~:shadow.build.classpath/resource","shadow/grove/db.cljc"],"~:compiled-at",1693994118077,"^I",["^ ","^N","^N","^O","^N","^P","^P","^Q","^Q"],"~:resource-name","shadow/grove/db.cljc","~:warnings",[],"~:source","(ns shadow.grove.db\n  (:refer-clojure :exclude (ident? remove))\n  (:require [shadow.grove.db.ident :as ident]))\n\n#?(:cljs\n   (set! *warn-on-infer* false))\n\n#?(:clj\n   (defn keyword-identical? [a b]\n     (identical? a b)))\n\n(defn make-ident [type id]\n  #?(:clj (ident/->Ident type id)\n     :cljs (ident/->Ident type id nil)))\n\n(defn ident? [thing]\n  (ident/ident? thing))\n\n(defn ident-key [thing]\n  {:pre [(ident/ident? thing)]}\n  #?(:clj (:entity-type thing)\n     :cljs (.-entity-type ^Ident thing)))\n\n(defn ident-val [thing]\n  {:pre [(ident/ident? thing)]}\n  #?(:clj (:id thing)\n     :cljs (.-id ^Ident thing)))\n\n(defn ident-as-vec [ident]\n  [(ident-key ident)\n   (ident-val ident)])\n\n(defn parse-joins [spec joins]\n  (reduce-kv\n    (fn [spec attr val]\n      (if-not (and (vector? val)\n                   (or (= :one (first val))\n                       (= :many (first val))))\n        (throw (ex-info \"invalid join\" joins))\n\n        ;; FIXME: actually make use of :one/:many, right now relying and user supplying proper value\n        (update spec :joins assoc attr (second val))))\n    spec\n    joins))\n\n(defn parse-primary-key\n  [{:keys [entity-type] :as spec}\n   {:keys [primary-key] :as config}]\n  (cond\n    (and (not primary-key) (:ident-gen config))\n    spec\n\n    (keyword? primary-key)\n    (assoc spec\n      :ident-gen\n      #(make-ident entity-type (get % primary-key)))\n\n    (and (vector? primary-key) (every? keyword? primary-key))\n    (assoc spec\n      :ident-gen\n      (fn [item]\n        (make-ident entity-type\n          (mapv #(get item %) primary-key))))\n\n    :else\n    (throw (ex-info \"invalid :primary-key\" config))))\n\n(defn parse-entity-spec [entity-type {:keys [joins] :as config}]\n  {:pre [(keyword? entity-type)]}\n\n  (-> (assoc config :entity-type entity-type :joins {})\n      (parse-primary-key config)\n      (parse-joins joins)\n      ))\n\n(defn parse-schema [spec]\n  (reduce-kv\n    (fn [schema key {:keys [type] :as config}]\n      (cond\n        (= :entity type)\n        (assoc-in schema [:entities key] (parse-entity-spec key config))\n\n        ;; only have entities for now, will need custom config later\n        :else\n        (throw (ex-info \"unknown type\" {:key key :config config}))\n        ))\n    {:entities {}}\n    spec))\n\n(defn nav-fn [db key val]\n  (cond\n    (ident? val)\n    (get db val)\n\n    (coll? val)\n    (vary-meta val assoc\n      'clojure.core.protocols/datafy\n      (fn [m]\n        (vary-meta m assoc\n          'clojure.core.protocols/nav\n          (fn [m key val]\n            (if (ident? val)\n              (get db val)\n              val)))))\n\n    :else\n    val))\n\n(defn configure [init-db spec]\n  ;; FIXME: should this use a special key instead of meta?\n  (let [schema (parse-schema spec)\n        m {::schema schema\n           ::ident-types (set (keys (:entities schema)))\n           ;; FIXME: conditionalize this, not necessary in release builds\n           ;; convenient for when tapping the db for inspect\n           'clojure.core.protocols/nav nav-fn}]\n\n    (with-meta init-db m)))\n\n\n(defn coll-key [thing]\n  {:pre [(ident? thing)]}\n  [::all (ident-key thing)])\n\n\n(defn- normalize* [imports schema entity-type item]\n  (let [{:keys [ident-gen id-pred joins] :as ent-config}\n        (get-in schema [:entities entity-type])\n\n        item-ident\n        (get item :db/ident)\n\n        ident\n        (ident-gen item)\n\n        _ (when (and item-ident (not= item-ident ident))\n            (throw (ex-info \"item contained ident but we generated a different one\" {:item item :ident ident})))\n\n        ;; FIXME: can an item ever have more than one ident?\n        item\n        (if (= item-ident ident)\n          item\n          (assoc item :db/ident ident))\n\n        item\n        (reduce-kv\n          (fn [item key join-type]\n            (let [curr-val\n                  (get item key ::skip)\n\n                  norm-val\n                  (cond\n                    (keyword-identical? ::skip curr-val)\n                    curr-val\n\n                    ;; already normalized, no nothing\n                    (ident? curr-val)\n                    ::skip\n\n                    (map? curr-val)\n                    (normalize* imports schema join-type curr-val)\n\n                    (vector? curr-val)\n                    (mapv #(normalize* imports schema join-type %) curr-val)\n\n                    ;; FIXME: add back predicate to check if curr-val is valid id-val to make ident\n                    ;; might be garbage leading to invalid ident stored in norm db\n                    (some? curr-val)\n                    (make-ident join-type curr-val)\n\n                    :else\n                    (throw (ex-info \"unexpected value in join attr\"\n                             {:item item\n                              :key key\n                              :val curr-val\n                              :type type})))]\n\n              (if (keyword-identical? norm-val ::skip)\n                item\n                (assoc item key norm-val))))\n          item\n          joins)]\n\n    (swap! imports conj [ident item])\n\n    ident))\n\n(defn- normalize\n  \"returns a seq of [[ident item] ...] tuples\"\n  [schema entity-type vals]\n  (let [imports (atom [])]\n\n    (cond\n      (map? vals)\n      (normalize* imports schema entity-type vals)\n\n      (sequential? vals)\n      (doseq [item vals]\n        (normalize* imports schema entity-type item))\n\n      :else\n      (throw (ex-info \"cannot import\" {:entity-type entity-type :vals vals})))\n\n    @imports\n    ))\n\n(comment\n  (let [schema\n        {:foo\n         {:type :entity\n          :primary-key :foo-id\n          :joins {:bar [:one :bar]\n                  :baz [:one :baz]}}\n         :bar\n         {:type :entity\n          :primary-key :bar-id}}\n\n        db\n        (configure {} schema)]\n\n    (-> (transacted db)\n        (add :foo {:foo-id 1 :foo \"foo\" :bar {:bar-id 1 :bar \"bar\"}})\n        (commit!)\n        (get :data))))\n\n(defn- set-conj [x y]\n  (if (nil? x)\n    #{y}\n    (conj x y)))\n\n(defn merge-or-replace [left right]\n  (if (keyword-identical? :db/loading left)\n    right\n    (merge left right)))\n\n(defn- merge-imports [data imports]\n  (reduce\n    (fn [data [ident item]]\n      (update data ident merge-or-replace item))\n    data\n    imports))\n\n(defn merge-seq\n  ([data entity-type coll]\n   (merge-seq data entity-type coll nil))\n  ([data entity-type coll target-path-or-fn]\n   {:pre [(sequential? coll)]}\n   (let [{::keys [schema]}\n         (meta data)\n\n         _ (when-not schema\n             (throw (ex-info \"data missing schema\" {:data data})))\n\n         {:keys [ident-gen] :as entity-spec}\n         (get-in schema [:entities entity-type])\n\n         _ (when-not entity-spec\n             (throw (ex-info \"entity not defined\" {:entity-type entity-type})))\n\n         idents\n         (->> coll\n              (map ident-gen)\n              (into []))\n\n         imports\n         (normalize schema entity-type coll)]\n\n     (-> data\n         (merge-imports imports)\n         (cond->\n           (vector? target-path-or-fn)\n           (assoc-in target-path-or-fn idents)\n\n           (fn? target-path-or-fn)\n           (target-path-or-fn idents))\n         ))))\n\n(defn add\n  ([data entity-type item]\n   (add data entity-type item nil))\n  ([data entity-type item target-path]\n   {:pre [(map? item)]}\n   (let [{::keys [schema]}\n         (meta data)\n\n         _ (when-not schema\n             (throw (ex-info \"data missing schema\" {:data data})))\n\n         {:keys [ident-gen] :as entity-spec}\n         (get-in schema [:entities entity-type])\n\n         _ (when-not entity-spec\n             (throw (ex-info \"entity not defined\" {:entity-type entity-type})))\n\n         ident\n         (ident-gen item)\n\n         imports\n         (normalize schema entity-type [item])]\n\n     (-> data\n         (merge-imports imports)\n         (cond->\n           target-path\n           (update-in target-path conj ident))))))\n\n(defn update-entity [data entity-type id update-fn & args]\n  ;; FIXME: validate that both entity-type is defined and id matches type\n  (update data (make-ident entity-type id) #(apply update-fn % args)))\n\n(defn all-idents-of [db entity-type]\n  ;; FIXME: check in schema if entity-type is actually declared\n  (get db [::all entity-type]))\n\n(defn all-of [db entity-type]\n  (->> (all-idents-of db entity-type)\n       (map #(get db %))))\n\n;; keep this as the very last thing since we excluded clojure remove\n;; don't want to write code that assumes it uses core remove\n(defn remove [data thing]\n  (cond\n    (ident? thing)\n    (dissoc data thing)\n\n    (and (map? thing) (:db/ident thing))\n    (dissoc data (:db/ident thing))\n\n    :else\n    (throw (ex-info \"don't know how to remove thing\" {:thing thing}))))\n\n(defn remove-idents [data idents]\n  (reduce remove data idents))\n\n(defprotocol IObserved\n  (observed-keys [this]))\n\n#?(:clj\n   (deftype ObservedData\n     [^:unsynchronized-mutable keys-used\n      ^clojure.lang.IPersistentMap data]\n     IObserved\n     (observed-keys [_]\n       (persistent! keys-used))\n\n     clojure.lang.IMeta\n     (meta [_]\n       (.meta data))\n\n     ;; FIXME: implement rest of seq functions\n\n     clojure.lang.IPersistentMap\n     (assoc [this key val]\n       (throw (ex-info \"read-only\" {})))\n\n     (assocEx [this key val]\n       (throw (ex-info \"read-only\" {})))\n\n     (without [this key]\n       (throw (ex-info \"read-only\" {})))\n\n     (containsKey [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (.containsKey data key))\n\n     (valAt [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (.valAt data key))\n\n     (valAt [this key not-found]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (.valAt data key not-found))\n\n     (entryAt [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (.entryAt data key)))\n\n   :cljs\n   (deftype ObservedData [^:mutable keys-used ^not-native data]\n     IObserved\n     (observed-keys [_]\n       (persistent! keys-used))\n\n     IMeta\n     (-meta [_]\n       (-meta data))\n\n     ;; map? predicate checks for this protocol\n     IMap\n     (-dissoc [coll k]\n       (throw (ex-info \"observed data is read-only\" {})))\n\n     IAssociative\n     (-contains-key? [coll k]\n       (-contains-key? data k))\n     (-assoc [coll k v]\n       (throw (ex-info \"observed data is read-only, assoc not allowed\" {:k k :v v})))\n\n     ILookup\n     (-lookup [_ key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (-lookup data key))\n\n     (-lookup [_ key default]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (set! keys-used (conj! keys-used key))\n       (-lookup data key default))))\n\n(defn observed [data]\n  (ObservedData. (transient #{}) data))\n\n#?(:clj\n   (defprotocol ITxCheck\n     (check-completed! [this])))\n\n(defprotocol ITxCommit\n  (commit! [this]))\n\n#?(:clj\n   (deftype TransactedData\n     [^clojure.lang.IPersistentMap data\n      keys-new\n      keys-updated\n      keys-removed\n      ;; using a ref not a mutable local since it must apply to all created instances of this\n      ;; every \"write\" creates a new instance\n      completed-ref]\n\n     ;; useful for debugging purposes that want the actual data\n     clojure.lang.IDeref\n     (deref [_]\n       data)\n\n     clojure.lang.IMeta\n     (meta [_]\n       (.meta data))\n\n     clojure.lang.IPersistentMap\n     (count [this]\n       (.count data))\n\n     (containsKey [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (.containsKey data key))\n\n     (valAt [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (.valAt data key))\n\n     (valAt [this key not-found]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (.valAt data key not-found))\n\n     (entryAt [this key]\n       (when (nil? key)\n         (throw (ex-info \"cannot read nil key\" {})))\n       (.entryAt data key))\n\n     (assoc [this key value]\n       (check-completed! this)\n\n       (when (nil? key)\n         (throw (ex-info \"nil key not allowed\" {:value value})))\n\n       ;; FIXME: should it really check each write if anything changed?\n       ;; FIXME: enforce that ident keys have a map value with ::ident key?\n       (let [prev-val\n             (.valAt data key ::not-found)\n\n             ;; FIXME: this should only be checking the key\n             ;; but since using vectors as ident we can't tell the difference from\n             ;; [::all :some.app.model/thing]\n             is-ident-update?\n             (and (ident? key)\n                  (contains? (::ident-types (meta data)) (ident-key key)))]\n\n         (if (identical? prev-val value)\n           this\n           (if (= ::not-found prev-val)\n             ;; new\n             (if-not is-ident-update?\n               ;; new non-ident key\n               (TransactedData.\n                 (assoc data key value)\n                 (conj! keys-new key)\n                 keys-updated\n                 keys-removed\n                 completed-ref)\n\n               ;; new ident\n               (TransactedData.\n                 (-> data\n                     (assoc key value)\n                     (update (coll-key key) set-conj key))\n                 (conj! keys-new key)\n                 (conj! keys-updated (coll-key key))\n                 keys-removed\n                 completed-ref))\n\n             ;; update, non-ident key\n             (if-not is-ident-update?\n               (TransactedData.\n                 (assoc data key value)\n                 (conj! keys-updated key)\n                 (conj! keys-updated key)\n                 keys-removed\n                 completed-ref)\n\n               ;; FIXME: no need to track (ident-key key) since it should be present?\n               (TransactedData.\n                 (.assoc data key value)\n                 keys-new\n                 (-> keys-updated\n                     (conj! key)\n                     ;; need to update the entity-type collection since some queries might change if one in the list changes\n                     ;; FIXME: this makes any update potentially expensive, maybe should leave this to the user?\n                     (conj! (coll-key key)))\n                 keys-removed\n                 completed-ref))\n             ))))\n\n     (assocEx [this key value]\n       (check-completed! this)\n\n       (when (nil? key)\n         (throw (ex-info \"nil key not allowed\" {:value value})))\n\n       ;; FIXME: should it really check each write if anything changed?\n       ;; FIXME: enforce that ident keys have a map value with ::ident key?\n       (let [prev-val\n             (.valAt data key ::not-found)\n\n             ;; FIXME: this should only be checking the key\n             ;; but since using vectors as ident we can't tell the difference from\n             ;; [::all :some.app.model/thing]\n             is-ident-update?\n             (and (ident? key)\n                  (contains? (::ident-types (meta data)) (ident-key key)))]\n\n         (if (identical? prev-val value)\n           this\n           (if (= ::not-found prev-val)\n             ;; new\n             (if-not is-ident-update?\n               ;; new non-ident key\n               (TransactedData.\n                 (.assocEx data key value)\n                 (conj! keys-new key)\n                 keys-updated\n                 keys-removed\n                 completed-ref)\n\n               ;; new ident\n               (TransactedData.\n                 (-> data\n                     (.assocEx key value)\n                     (update (coll-key key) set-conj key))\n                 (conj! keys-new key)\n                 (conj! keys-updated (coll-key key))\n                 keys-removed\n                 completed-ref))\n\n             ;; update, non-ident key\n             (if-not is-ident-update?\n               (TransactedData.\n                 (.assocEx data key value)\n                 keys-new\n                 (conj! keys-updated key)\n                 keys-removed\n                 completed-ref)\n\n               ;; FIXME: no need to track (ident-key key) since it should be present?\n               (TransactedData.\n                 (.assocEx data key value)\n                 keys-new\n                 (-> keys-updated\n                     (conj! key)\n                     ;; need to update the entity-type collection since some queries might change if one in the list changes\n                     ;; FIXME: this makes any update potentially expensive, maybe should leave this to the user?\n                     (conj! (coll-key key)))\n                 keys-removed\n                 completed-ref))\n             ))))\n\n     (without [this key]\n       (check-completed! this)\n\n       (let [key-is-ident?\n             (ident? key)\n\n             next-data\n             (-> (.without data key)\n                 (cond->\n                   key-is-ident?\n                   (update (coll-key key) disj key)))\n\n             next-removed\n             (-> keys-removed\n                 (conj! key)\n                 (cond->\n                   key-is-ident?\n                   (conj! (coll-key key))))]\n\n         (TransactedData.\n           next-data\n           keys-new\n           keys-updated\n           next-removed\n           completed-ref)))\n\n     ITxCheck\n     (check-completed! [this]\n       (when @completed-ref\n         (throw (ex-info \"transaction concluded, don't hold on to db while in tx\" {}))))\n\n     ITxCommit\n     (commit! [_]\n       (vreset! completed-ref true)\n       {:data data\n        :keys-new (persistent! keys-new)\n        :keys-updated (persistent! keys-updated)\n        :keys-removed (persistent! keys-removed)}))\n\n   :cljs\n   (deftype TransactedData\n     [^not-native data\n      keys-new\n      keys-updated\n      keys-removed\n      ;; using a ref not a mutable local since it must apply to all created instances of this\n      ;; every \"write\" creates a new instance\n      completed-ref]\n\n     ;; useful for debugging purposes that want the actual data\n     IDeref\n     (-deref [_]\n       data)\n\n     IMeta\n     (-meta [_]\n       (-meta data))\n\n     ILookup\n     (-lookup [this key]\n       (.check-completed! this)\n       (-lookup data key))\n\n     (-lookup [this key default]\n       (.check-completed! this)\n       (-lookup data key default))\n\n     ICounted\n     (-count [this]\n       (.check-completed! this)\n       (-count data))\n\n     IMap\n     (-dissoc [this key]\n       (.check-completed! this)\n\n       (let [key-is-ident?\n             (ident? key)\n\n             next-data\n             (-> (-dissoc data key)\n                 (cond->\n                   key-is-ident?\n                   (update (coll-key key) disj key)))\n\n             next-removed\n             (-> keys-removed\n                 (conj! key)\n                 (cond->\n                   key-is-ident?\n                   (conj! (coll-key key))))]\n\n         (TransactedData.\n           next-data\n           keys-new\n           keys-updated\n           next-removed\n           completed-ref)))\n\n     IAssociative\n     (-contains-key? [coll k]\n       (-contains-key? data k))\n\n     (-assoc [this key value]\n       (.check-completed! this)\n\n       (when (nil? key)\n         (throw (ex-info \"nil key not allowed\" {:value value})))\n\n       ;; FIXME: should it really check each write if anything changed?\n       ;; FIXME: enforce that ident keys have a map value with ::ident key?\n       (let [prev-val\n             (-lookup data key ::not-found)\n\n             ;; FIXME: this should only be checking the key\n             ;; but since using vectors as ident we can't tell the difference from\n             ;; [::all :some.app.model/thing]\n             is-ident-update?\n             (and (ident? key)\n                  (contains? (::ident-types (meta data)) (ident-key key)))]\n\n         (if (identical? prev-val value)\n           this\n           (if (= ::not-found prev-val)\n             ;; new\n             (if-not is-ident-update?\n               ;; new non-ident key\n               (TransactedData.\n                 (-assoc data key value)\n                 (conj! keys-new key)\n                 keys-updated\n                 keys-removed\n                 completed-ref)\n\n               ;; new ident\n               (TransactedData.\n                 (-> data\n                     (-assoc key value)\n                     (update (coll-key key) set-conj key))\n                 (conj! keys-new key)\n                 (conj! keys-updated (coll-key key))\n                 keys-removed\n                 completed-ref))\n\n             ;; update, non-ident key\n             (if-not is-ident-update?\n               (TransactedData.\n                 (-assoc data key value)\n                 keys-new\n                 (conj! keys-updated key)\n                 keys-removed\n                 completed-ref)\n\n               ;; FIXME: no need to track (ident-key key) since it should be present?\n               (TransactedData.\n                 (-assoc data key value)\n                 keys-new\n                 (-> keys-updated\n                     (conj! key)\n                     ;; need to update the entity-type collection since some queries might change if one in the list changes\n                     ;; FIXME: this makes any update potentially expensive, maybe should leave this to the user?\n                     (conj! (coll-key key)))\n                 keys-removed\n                 completed-ref))\n             ))))\n\n     ICollection\n     (-conj [coll ^not-native entry]\n       (if (vector? entry)\n         (-assoc coll (-nth entry 0) (-nth entry 1))\n         (loop [^not-native ret coll\n                es (seq entry)]\n           (if (nil? es)\n             ret\n             (let [^not-native e (first es)]\n               (if (vector? e)\n                 (recur\n                   (-assoc ret (-nth e 0) (-nth e 1))\n                   (next es))\n                 (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n     ITxCommit\n     (commit! [_]\n       (vreset! completed-ref true)\n       {:data data\n        :keys-new (persistent! keys-new)\n        :keys-updated (persistent! keys-updated)\n        :keys-removed (persistent! keys-removed)})\n\n     Object\n     (check-completed! [this]\n       (when @completed-ref\n         (throw (ex-info \"transaction concluded, don't hold on to db while in tx\" {}))))))\n\n(defn transacted [data]\n  (TransactedData.\n    data\n    (transient #{})\n    (transient #{})\n    (transient #{})\n    (volatile! false)))","~:reader-features",["^D",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings",";AAKG,AAMH,6BAAA,7BAAMA,kEAAYC,KAAKC;AAAvB,AAEW,gDAAA,zCAACC,iCAAcF,KAAKC;;AAE/B,+BAAA,/BAAME,sEAAQC;AAAd,AACE,OAACC,mCAAaD;;AAEhB,4BAAA,5BAAMG,gEAAWH;AAAjB,AAAA,GACS,AAACC,mCAAaD;AADvB;AAAA,AAAA,MAAA,KAAAE,MAAA;;;AAGW,OAAsBF;;AAEjC,4BAAA,5BAAMI,gEAAWJ;AAAjB,AAAA,GACS,AAACC,mCAAaD;AADvB;AAAA,AAAA,MAAA,KAAAE,MAAA;;;AAGW,OAAaF;;AAExB,+BAAA,/BAAMK,sEAAcC;AAApB,AAAA,0FACG,AAACH,0BAAUG,OACX,AAACF,0BAAUE;;AAEd,8BAAA,9BAAMC,oEAAaC,KAAKC;AAAxB,AACE,OAACC,oBACC,WAAKF,SAAKG,KAAKC;AAAf,AACE,GAAA,GAAQ,EAAK,AAACC,wBAAQD,UACT,EAAI,6CAAA,7CAACE,+FAAO,AAACC,gBAAMH,WACf,6CAAA,7CAACE,kGAAQ,AAACC,gBAAMH;AAC/B,MAAO,gDAAA,hDAACI,+DAAuBP;;AAG/B,+DAAA,xDAACQ,+CAAOT,gEAAYU,gBAAMP,KAAK,AAACQ,iBAAOP;;GAC3CJ,KACAC;;AAEJ,oCAAA,4CAAAW,SAAAC,zFAAMK;AAAN,AAAA,IAAAJ,aAAAF;IAAAE,iBAAA,AAAAC,4BAAAD;WAAAA,PAC4Bd;kBAD5B,AAAAgB,4CAAAF,eAAA,zEACWK;IADXF,aAAAJ;IAAAI,iBAAA,AAAAF,4BAAAE;aAAAA,TAE4BI;kBAF5B,AAAAL,4CAAAC,eAAA,zEAEWG;AAFX,AAGE,oBACE,iBAAAE,oBAAK,AAACC,cAAIH;AAAV,AAAA,GAAAE;AAAuB,OAAA,4FAAYD;;AAAnCC;;;AACAtB;;AAFF,GAIE,wBAAAwB,vBAAUJ;AACV,0DAAA,8DAAA,WAAAK,5HAACC,8CAAM1B;AAAP,AAEG,OAACb,2BAAWgC,YAAY,4CAAAM,5CAACT,6DAAMI;;;AAPpC,GASE,EAAK,AAACf,wBAAQe,kBAAa,AAACO,uBAAOC,yBAASR;AAC5C,0DAAA,nDAACM,8CAAM1B,mEAEL,WAAK6B;AAAL,AACE,OAAC1C,2BAAWgC,YACV,6CAAA,WAAAW,xDAACC;AAAD,AAAO,wDAAAD,jDAACd,4CAAIa;GAAQT;;;AAd5B,AAiBE,MAAO,gDAAA,hDAACZ,uEAA+Ba;;;;;;AAE3C,oCAAA,wDAAAW,5FAAME,gFAAmBf;AAAzB,AAAA,IAAAc,aAAAD;IAAAC,iBAAA,AAAAlB,4BAAAkB;aAAAA,TAAwDZ;YAAxD,AAAAL,4CAAAiB,eAAA,nEAA6ChC;AAA7C,AAAA,GACS,wBAAAuB,vBAAUL;AADnB;AAAA,AAAA,MAAA,KAAAzB,MAAA;;;qEAGM,4DAAA,kIAAA,uDAAA,rPAACgC,qDAAML,2EAAoBF,lKAC3B,AAACD,gUAAkBG,nWACnB,OAACtB,oWAAYE;;AAGnB,+BAAA,/BAAMkC,sEAAcnC;AAApB,AACE,OAACE,oBACC,sBAAAkC,XAAKE,OAAOC;AAAZ,AAAA,IAAAF,aAAAD;IAAAC,iBAAA,AAAAtB,4BAAAsB;aAAAA,TAAkChB;WAAlC,AAAAL,4CAAAqB,eAAA,lEAAwBjD;AAAxB,AACE,GACE,6CAAA,7CAACkB,sGAAUlB;AACX,iCAAA,mFAAA,7GAACoD,mBAASF,uJAAkBC,YAAK,AAACL,kCAAkBK,IAAIlB;;AAF1D,AAME,MAAO,gDAAA,eAAA,2CAAA,wDAAA,lKAACb,8JAA6B+B,4DAAYlB;;;GARvD,2CAAA,6DAAA,2CAWErB;;AAEJ,yBAAA,zBAAMyC,0DAAQC,GAAGH,IAAInC;AAArB,AACE,GACE,AAACb,6BAAOa;AACR,OAACY,4CAAI0B,GAAGtC;;AAFV,GAIE,AAACuC,sBAAMvC;AACP,6EAAA,AAAA,tEAACwC,kDAAUxC,IAAIM,uHAEb,WAAKmC;AAAL,AACE,2EAAA,AAAA,pEAACD,kDAAUC,EAAEnC,iHAEX,WAAKmC,MAAEN,QAAInC;AAAX,AACE,GAAI,AAACb,6BAAOa;AACV,OAACY,4CAAI0B,GAAGtC;;AACRA;;;;;AAbZ,AAgBEA;;;;;AAEJ,4BAAA,5BAAM0C,gEAAWC,QAAQ/C;AAAzB,AAEE,IAAMsC,SAAO,AAACH,6BAAanC;QAA3B,2CAAA,6FAAA,mOAAA,AAAA,/WACM6C,qIAAYP,wGACK,AAACU,cAAI,AAACC,eAAK,AAAA,2FAAWX,2GAGRG;AALrC,AAOE,OAACS,oBAAUH,QAAQF;;AAGvB,2BAAA,3BAAMM,8DAAU3D;AAAhB,AAAA,GACS,AAACD,6BAAOC;AADjB;AAAA,AAAA,MAAA,KAAAE,MAAA;;;AAAA,0FAAA,gFAES,AAACC,0BAAUH;;AAGpB,kCAAA,lCAAO4D,4EAAYC,QAAQf,OAAOnB,YAAYU;AAA9C,AACE,IAAAyB,aACM,sDAAA,mFAAA,zIAACI,+CAAOpB,uJAAkBnB;IADhCmC,iBAAA,AAAAvC,4BAAAuC;iBAAAA,bAA2CG;gBAA3C,AAAAzC,4CAAAsC,eAAA,vEAAcC;cAAd,AAAAvC,4CAAAsC,eAAA,rEAAwBE;YAAxB,AAAAxC,4CAAAsC,eAAA,nEAAgCrD;IAG1B0D,aACA,iDAAA,jDAAC3C,4CAAIa;IAEL/B,QACA,CAACyD,0CAAAA,gDAAAA,RAAU1B,4BAAAA;IAEX+B,IAAE,kBAAM,iBAAAtC,oBAAKqC;AAAL,AAAA,oBAAArC;AAAgB,OAACuC,gDAAKF,WAAW7D;;AAAjCwB;;MAAN,qSAAA,rSACE,kBAAO,gDAAA,wDAAA,2CAAA,yDAAA,5MAACd,uMAAuEqB,yDAAY/B;IAG/F+B,WACA,EAAI,AAACvB,6CAAEqD,WAAW7D,QAChB+B,KACA,mDAAA,nDAACH,8CAAMG,4DAAe/B;IAExB+B,WACA,AAAC3B,oBACC,WAAK2B,SAAKU,IAAIuB;AAAd,AACE,IAAMC,WACA,yDAAA,zDAAC/C,4CAAIa,SAAKU;IAEVyB,WACA,4IAAA,0CAAA,mFAAA,oRAAA,3hBACE,mCAAA,nCAACC,sHAA0BF,WAC3BA,WAGA,AAACxE,6BAAOwE,gGAGR,AAACG,qBAAKH,WACN,CAACX,gEAAAA,mGAAAA,rCAAWC,+EAAAA,vEAAQf,+EAAAA,xEAAOwB,+EAAAA,rEAAUC,+EAAAA,aAErC,AAAC1D,wBAAQ0D,WACT,6CAAA,WAAAI,xDAACpC;AAAD,AAAO,+JAAAoC,uFAAAA,9OAACf,gEAAAA,2GAAAA,7CAAWC,uFAAAA,/EAAQf,uFAAAA,hFAAOwB,uFAAAA;aAZpC,0EAAA,pFAYiDC,YAI/C,GAAA,aAAA,ZAAOA,qBACP,AAAC5E,2BAAW2E,UAAUC,UAGtB,kBAAO,gDAAA,gCAAA,2CAAA,6DAAA,wDAAA,2DAAA,3SAACvD,+KACQqB,6DACDU,sDACAwB,8DACCK;;AA5BxB,AA8BE,GAAI,4CAAA,5CAACH,mCAAmBD;AACtBnC;;AACA,OAACH,8CAAMG,SAAKU,IAAIyB;;GACtBnC,SACA5B;AAvDR,AAyDE,0EAAA,1EAACoE,mDAAMhB,QAAQiB,kGAAMxE,MAAM+B;;AAE3B/B;;AAEJ;;;4BAAA,5BAAOyE,gEAEJjC,OAAOnB,YAAYqD;AAFtB,AAGE,IAAMnB,UAAQ,6CAAA,7CAACqB;AAAf,AAEE,GACE,AAACR,qBAAKM;AACN,AAACpB,gCAAWC,QAAQf,OAAOnB,YAAYqD;;AAFzC,GAIE,AAACG,4BAAYH;AACb,IAAAI,mBAAA,AAAAC,cAAaL;IAAbM,qBAAA;IAAAC,qBAAA;IAAAC,iBAAA;;AAAA,AAAA,GAAA,AAAA,CAAAA,iBAAAD;AAAA,iBAAA,AAAAD,wDAAAE,rEAAQnD;AAAR,AAAA,AACE,AAACuB,gCAAWC,QAAQf,OAAOnB,YAAYU;;AADzC;AAAA,eAAA+C;eAAAE;eAAAC;eAAA,CAAAC,iBAAA;;;;;;;AAAA,IAAAC,2BAAA,AAAAJ,cAAAD;AAAA,AAAA,GAAAK;AAAA,AAAA,IAAAL,uBAAAK;AAAA,AAAA,GAAA,AAAAC,6BAAAN;AAAA,IAAAO,wBAAA,AAAAC,sBAAAR;AAAA,AAAA,eAAA,AAAAS,qBAAAT;eAAAO;eAAA,AAAAG,gBAAAH;eAAA;;;;;;;AAAA,iBAAA,AAAA5E,gBAAAqE,7BAAQ/C;AAAR,AAAA,AACE,AAACuB,gCAAWC,QAAQf,OAAOnB,YAAYU;;AADzC;AAAA,eAAA,AAAA0D,eAAAX;eAAA;eAAA;eAAA;;;;;;;;AAAA;;;;;AALF,AASE,MAAO,gDAAA,gBAAA,2CAAA,gFAAA,3LAACpE,+KAAsCW,gEAAkBqD;;;;;AAXpE,OAAAC,gBAaGpB;;AAGL,AAmBA,2BAAA,3BAAOmC,8DAAUC,EAAEC;AAAnB,AACE,GAAI,MAAA,LAAMD;AAAV,sDACIC;;AACF,OAACC,6CAAKF,EAAEC;;;AAEZ,mCAAA,nCAAME,8EAAkBC,KAAKC;AAA7B,AACE,GAAI,mCAAA,nCAAC7B,iGAA+B4B;AAClCC;;AACA,OAACC,uGAAMF,KAAKC;;;AAEhB,gCAAA,hCAAOE,wEAAeC,KAAK5C;AAA3B,AACE,OAAC6C,+CACC,oBAAAC,TAAKF;AAAL,AAAA,IAAAG,aAAAD;YAAA,AAAAE,4CAAAD,WAAA,IAAA,nEAAWtG;WAAX,AAAAuG,4CAAAD,WAAA,IAAA,lEAAiBvE;AAAjB,AACE,OAACpB,+CAAOwF,SAAKnG,MAAM8F,iCAAiB/D;GACtCoE,KACA5C;;AAEJ,AAAA,4BAAA,oCAAAiD,hEAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA9G,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,0DAAA,1DAAM8G,qEACFP,KAAK9E,YAAYsF;AADrB,AAEG,qFAAA,9EAACC,wDAAUT,KAAK9E,YAAYsF;;;AAF/B,CAAA,0DAAA,1DAAMD,qEAGFP,KAAK9E,YAAYsF,KAAKE;AAH1B,AAAA,GAIU,AAAChC,4BAAY8B;AAJvB;AAAA,AAAA,MAAA,KAAA/G,MAAA;;;AAKG,IAAAkH,aACM,AAACE,eAAKb;IADZW,iBAAA,AAAA7F,4BAAA6F;aAAA,AAAA5F,4CAAA4F,eAAA,pEAAetE;IAGTsB,IAAE,0BAAA,KAAA,bAAUtB,aACR,kBAAO,gDAAA,sBAAA,2CAAA,jHAAC9B,sKAAqCyF;IAJvDY,aAOM,sDAAA,mFAAA,zIAACnD,+CAAOpB,uJAAkBnB;IAPhC0F,iBAAA,AAAA9F,4BAAA8F;kBAAAA,dAM6BE;gBAN7B,AAAA/F,4CAAA6F,eAAA,vEAMctD;IAGRK,QAAE,+BAAA,KAAA,lBAAUmD,kBACR,kBAAO,gDAAA,qBAAA,2CAAA,hHAACvG,oLAA2CW;IAEvD6F,6IACKP,tDACA,AAACQ,4CAAI1D,1HACL,6CAAA,7CAAC2D;IAEN7D,UACA,AAACkB,0BAAUjC,OAAOnB,YAAYsF;AAlBpC,6CAoBMR,9BACA,AAACD,mCAAc3C,lDACf,IAAA8D;IAAAA,eAAA,oGAAAA,lGACE,AAAC9G,wBAAQsG,oBACT,mBAAAQ,nBAAC3E,4BAASmE,kBAAkBK;AAF9B,AAAA,GAIE,AAACI,oBAAIT;AACL,0GAAAQ,mDAAAA,rJAACR,kDAAAA,uEAAAA,VAAkBK,mDAAAA;;AALrBG;;;;AA3BT,CAAA,oDAAA,pDAAMX;;AAAN,AAmCA,AAAA,sBAAA,8BAAAF,pDAAMgB;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA5H,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,oDAAA,pDAAM4H,+DACFrB,KAAK9E,YAAYU;AADrB,AAEG,+EAAA,xEAAC0F,kDAAItB,KAAK9E,YAAYU;;;AAFzB,CAAA,oDAAA,pDAAMyF,+DAGFrB,KAAK9E,YAAYU,KAAK2F;AAH1B,AAAA,GAIU,AAACtD,qBAAKrC;AAJhB;AAAA,AAAA,MAAA,KAAAnC,MAAA;;;AAKG,IAAA+H,aACM,AAACX,eAAKb;IADZwB,iBAAA,AAAA1G,4BAAA0G;aAAA,AAAAzG,4CAAAyG,eAAA,pEAAenF;IAGTsB,IAAE,0BAAA,KAAA,bAAUtB,aACR,kBAAO,gDAAA,sBAAA,2CAAA,jHAAC9B,sKAAqCyF;IAJvDyB,aAOM,sDAAA,mFAAA,zIAAChE,+CAAOpB,uJAAkBnB;IAPhCuG,iBAAA,AAAA3G,4BAAA2G;kBAAAA,dAM6BX;gBAN7B,AAAA/F,4CAAA0G,eAAA,vEAMcnE;IAGRK,QAAE,+BAAA,KAAA,lBAAUmD,kBACR,kBAAO,gDAAA,qBAAA,2CAAA,hHAACvG,oLAA2CW;IAEvDrB,QACA,CAACyD,0CAAAA,gDAAAA,RAAU1B,4BAAAA;IAEXwB,UACA,6CAAA,7CAACkB,0BAAUjC,OAAOnB,+FAAaU;AAhBrC,6CAkBMoE,9BACA,AAACD,mCAAc3C,lDACf,IAAAsE;AAAA,AAAA,oBACEH;AACA,yDAAAG,lDAACC,2DAAUJ,YAAYlD,eAAKxE;;AAF9B6H;;;;AAzBT,CAAA,8CAAA,9CAAML;;AAAN,AA6BA,AAAA,gCAAA,wCAAAhB,xEAAM4B;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,mEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,qEAAA,rEAAME,gFAAejC,KAAK9E,YAAY9B,GAAGoJ,UAAYC;AAArD,AAEE,sGAAA,WAAAC,1GAAClI,+CAAOwF,KAAK,AAAC9G,2BAAWgC,YAAY9B;AAArC,AAA0C,+DAAAsJ,xDAACC,8CAAMH,2BAAYC;;;;AAF/D,CAAA,wDAAA,xDAAMR;;AAAN;AAAA,CAAA,kDAAA,WAAAC,7DAAMD;AAAN,AAAA,IAAAE,WAAA,AAAA7H,gBAAA4H;IAAAA,eAAA,AAAA5C,eAAA4C;IAAAE,WAAA,AAAA9H,gBAAA4H;IAAAA,eAAA,AAAA5C,eAAA4C;IAAAG,WAAA,AAAA/H,gBAAA4H;IAAAA,eAAA,AAAA5C,eAAA4C;IAAAI,WAAA,AAAAhI,gBAAA4H;IAAAA,eAAA,AAAA5C,eAAA4C;AAAA,AAAA,IAAAK,qBAAA;AAAA,AAAA,OAAAA,wDAAAJ,SAAAC,SAAAC,SAAAC,SAAAJ;;;AAAA,AAIA,gCAAA,hCAAMU,wEAAenG,GAAGvB;AAAxB,AAEE,sDAAA,mFAAA,lIAACH,4CAAI0B,sKAAUvB;;AAEjB,yBAAA,zBAAM2H,0DAAQpG,GAAGvB;AAAjB,AAEO,mDAAA,WAAA4H,vDAAC9B;AAAD,AAAM,sDAAA8B,/CAAC/H,4CAAI0B;GADX,AAACmG,8BAAcnG,GAAGvB;;AAKzB,yBAAA,zBAAM6H,0DAAQ/C,KAAKzG;AAAnB,AACE,GACE,AAACD,6BAAOC;AACR,OAACyJ,+CAAOhD,KAAKzG;;AAFf,oBAIE,iBAAA8B,oBAAK,AAAC4C,qBAAK1E;AAAX,AAAA,GAAA8B;AAAkB,OAAA,qFAAW9B;;AAA7B8B;;;AACA,OAAC2H,+CAAOhD,KAAK,AAAA,qFAAWzG;;AAL1B,AAQE,MAAO,gDAAA,iCAAA,2CAAA,5HAACgB,kLAAiDhB;;;;;AAE7D,gCAAA,hCAAM0J,wEAAejD,KAAKe;AAA1B,AACE,OAACd,+CAAO8C,uBAAO/C,KAAKe;;AAEtB,AAAA;AAAA;;;4BAAA,5BAAa0C;;AAAb,IAAAP,oDAAA,WACkBQ;AADlB,AAAA,IAAAP,kBAAA,EAAA,UAAA,OAAA,hBACkBO,qBAAAA;IADlBN,kBAAA,CAAAC,8BAAA,AAAAC,YAAAH;AAAA,AAAA,GAAA,GAAA,CAAAC,mBAAA;AAAA,QAAAA,gDAAAA,uDAAAA,TACkBM,mCAAAA;;AADlB,IAAAH,kBAAA,CAAAF,8BAAA;AAAA,AAAA,GAAA,GAAA,CAAAE,mBAAA;AAAA,QAAAA,gDAAAA,uDAAAA,TACkBG,mCAAAA;;AADlB,MAAA,AAAAF,2BAAA,0BACkBE;;;;AADlB,AAAA,gCAAA,hCACGL,wEAAeK;AADlB,AAAA,GAAA,EAAA,GAAA,UAAA,aAAA,GAAA,CAAA,yDAAA,nFACkBA,0BAAAA;AADlB,OACkBA,sDAAAA;;AADlB,OAAAR,kDACkBQ;;;;AADlB,AAoDG,AAAA;;;;;;;;;;;;;;;AAAA,AAAA,CAAA,AAAA,oEAAAC,pEAASK;;AAAT,CAAA,AAAA,yFAAA,zFAASA,oGAESrG;;AAFlB,AAAA,YAAA,RAEkBA;AAFlB,AAGI,OAACwG,2BAAYD;;;AAHjB,CAAA,AAAA,uEAAA,vEAASF,kFAMCrG;;AANV,AAAA,YAAA,RAMUA;AANV,AAOI,OAAOqC;;;AAPX,CAAA,AAAA,wEAAA,xEAASgE,mFAWGxD,KAAK4D;;AAXjB,AAAA,eAAA,XAWY5D;AAXZ,AAYI,MAAO,gDAAA,6BAAA,7EAACjG;;;AAZZ,CAAA,AAAA,6FAAA,7FAASyJ,wGAeUxD,KAAK4D;;AAfxB,AAAA,eAAA,XAemB5D;AAfnB,AAgBI,OAAgBR,qEAAKoE;;;AAhBzB,CAAA,AAAA,+EAAA,/EAASJ,0FAiBExD,KAAK4D,EAAEC;;AAjBlB,AAAA,eAAA,XAiBW7D;AAjBX,AAkBI,MAAO,gDAAA,gDAAA,2CAAA,kDAAA,7LAACjG,2LAA4D6J,+CAAKC;;;AAlB7E,CAAA,AAAA,2EAAA,3EAASL,sFAqBGrG,EAAErB;;AArBd,AAAA,YAAA,RAqBYqB;AArBZ,AAsBI,GAAM,QAAA,PAAMrB;AAAZ,AACE,MAAO,gDAAA,sBAAA,tEAAC/B;;AADV;;AAEA,CAAM2J,mBAAU,AAACI,mDAAMJ,iBAAU5H;;AACjC,OAAS0D,mDAAK1D;;;AAzBlB,CAAA,AAAA,2EAAA,3EAAS0H,sFA2BGrG,EAAErB,IAAIiI;;AA3BlB,AAAA,YAAA,RA2BY5G;AA3BZ,AA4BI,GAAM,QAAA,PAAMrB;AAAZ,AACE,MAAO,gDAAA,sBAAA,tEAAC/B;;AADV;;AAEA,CAAM2J,mBAAU,AAACI,mDAAMJ,iBAAU5H;;AACjC,OAAS0D,mDAAK1D,IAAIiI;;;AA/BtB,CAAA,wCAAA,xCAASP;AAAT,AAAA,AAAA;;;AAAA,CAAA,8CAAA,9CAASA;;AAAT,CAAA,iDAAA,jDAASA;;AAAT,CAAA,sDAAA,WAAAJ,mBAAAC,qBAAAC,zGAASE;AAAT,AAAA,OAAAD,iBAAAF,qBAAA;;;AAAA;;;oCAAA,pCAASI,gFAAwBC,UAAsBlE;AAAvD,AAAA,YAAAgE,6BAAiCE,UAAsBlE;;;AAA9CgE,AAiCZ,2BAAA,3BAAMQ,8DAAUxE;AAAhB,AACE,YAAAgE,6BAAe,qBAAA,rBAACS,wDAAezE;;AAMjC,AAAA;AAAA;;;4BAAA,5BAAa4E;;AAAb,IAAAF,mDAAA,WACYhB;AADZ,AAAA,IAAAP,kBAAA,EAAA,UAAA,OAAA,hBACYO,qBAAAA;IADZN,kBAAA,CAAAuB,6BAAA,AAAArB,YAAAH;AAAA,AAAA,GAAA,GAAA,CAAAC,mBAAA;AAAA,QAAAA,gDAAAA,uDAAAA,TACYM,mCAAAA;;AADZ,IAAAH,kBAAA,CAAAoB,6BAAA;AAAA,AAAA,GAAA,GAAA,CAAApB,mBAAA;AAAA,QAAAA,gDAAAA,uDAAAA,TACYG,mCAAAA;;AADZ,MAAA,AAAAF,2BAAA,oBACYE;;;;AADZ,AAAA,+BAAA,/BACGiB,sEAASjB;AADZ,AAAA,GAAA,EAAA,GAAA,UAAA,aAAA,GAAA,CAAA,wDAAA,lFACYA,0BAAAA;AADZ,OACYA,qDAAAA;;AADZ,OAAAgB,iDACYhB;;;;AADZ,AAoNG,AAAA;;;;;;;;;;;;;;;;;;;;;AAAA,AAAA,CAAA,AAAA,iEAAA,jEAASmB;;AAAT,AAAA,YAAA,RAsJqBnB;AAtJrB,AAuJI,oBAAA,AAAAlF,gBAAO0G;AAAP,AACE,MAAO,gDAAA,yDAAA,zGAAC3K;;AADV;;;;AAvJJ,CAAA,AAAA,6EAAA,7EAASsK,wFAmBGnB,MAAKpH;;AAnBjB,AAAA,gBAAA,ZAmBYoH;AAnBZ,AAoBI,AAAmBA;;AACnB,OAAS1D,mDAAK1D;;;AArBlB,CAAA,AAAA,6EAAA,7EAASuI,wFAuBGnB,MAAKpH,IAAIiI;;AAvBrB,AAAA,gBAAA,ZAuBYb;AAvBZ,AAwBI,AAAmBA;;AACnB,OAAS1D,mDAAK1D,IAAIiI;;;AAzBtB,CAAA,AAAA,yEAAA,zEAASM,oFAeClH;;AAfV,AAAA,YAAA,RAeUA;AAfV,AAgBI,OAAOqC;;;AAhBX,CAAA,AAAA,6EAAA,7EAAS6E,wFA4BEnB;;AA5BX,AAAA,gBAAA,ZA4BWA;AA5BX,AA6BI,AAAmBA;;AACnB,OAAQ1D;;;AA9BZ,CAAA,AAAA,sEAAA2D,tEAASkB;;AAAT,CAAA,AAAA,0FAAA,1FAASA,qGA8IGlH;;AA9IZ,AAAA,YAAA,RA8IYA;AA9IZ,AA+II,4CAAA,5CAACuI,uBAAQhB;;AA/Ib,kDAAA,iEAAA,wGAAA,qHAAA,zOAgJWlF,wEACI,AAACmE,2BAAYY,sFACT,AAACZ,2BAAYa,0FACb,AAACb,2BAAYc;;;AAnJhC,CAAA,AAAA,0EAAA,1EAASJ,qFAiCGnB,MAAKpH;;AAjCjB,AAAA,gBAAA,ZAiCYoH;AAjCZ,AAkCI,AAAmBA;;AAEnB,IAAMyB,sBACA,AAAC7L,6BAAOgD;IAER8I,wCACI,AAASpF,gDAAK1D,5EACd,iBAAA+I;AAAA,AAAA,GACEF;AACA,sDAAAE,/CAAC7K,wDAAO,AAAC0C,yBAASZ,KAAKgJ,eAAKhJ;;AAF9B+I;;;IAIJE,8FACIN,nDACA,AAACX,uEAAMhI,nGACP,iBAAAkJ;AAAA,AAAA,GACEL;AACA,0DAAAK,nDAAClB,4DAAM,AAACpH,yBAASZ;;AAFnBkJ;;;AAZV,AAgBE,YAAAX,+BACEO,UACAL,gBACAC,oBACAO,aACAL;;;AAzDR,CAAA,AAAA,+FAAA,/FAASL,0GA4DUrE,KAAK4D;;AA5DxB,AAAA,eAAA,XA4DmB5D;AA5DnB,AA6DI,OAAgBR,qEAAKoE;;;AA7DzB,CAAA,AAAA,iFAAA,jFAASS,4FA+DEnB,MAAKpH,IAAImJ;;AA/DpB,AAAA,gBAAA,ZA+DW/B;AA/DX,AAgEI,AAAmBA;;AAEnB,GAAM,QAAA,PAAMpH;AAAZ,AACE,MAAO,gDAAA,sBAAA,2CAAA,jHAAC/B,uKAAsCkL;;AADhD;;AAKA,IAAMC,WACA,uDAAA,vDAAS1F,mDAAK1D;IAKdqJ,yBACA,EAAK,AAACrM,6BAAOgD,UACR,AAACsJ,0BAAU,AAAA,+HAAe,AAAC/E,eAAKb,cAAO,AAACtG,0BAAU4C;AAR7D,AAUE,GAAI,CAAYoJ,aAASD;AACvB/B;;AACA,GAAI,6CAAA,7CAACrJ,yIAAcqL;AAEjB,GAAA,GAAQC;AAEN,YAAAd,+BACE,AAAQ7E,uDAAK1D,IAAImJ,OACjB,AAACnB,mDAAMS,gBAASzI,KAChB0I,oBACAC,oBACAC;;AAGF,YAAAL,8EACM7E,AACA,uDAAQ1D,IAAImJ,1GACZ,AAACjL,iHAAO,AAAC0C,yBAASZ,KAAKiD,yBAASjD,KACpC,AAACgI,mDAAMS,gBAASzI,KAChB,AAACgI,mDAAMU,oBAAa,AAAC9H,yBAASZ,MAC9B2I,oBACAC;;;AAGJ,GAAA,GAAQS;AACN,YAAAd,+BACE,AAAQ7E,uDAAK1D,IAAImJ,OACjBV,gBACA,AAACT,mDAAMU,oBAAa1I,KACpB2I,oBACAC;;AAGF,YAAAL,+BACE,AAAQ7E,uDAAK1D,IAAImJ,OACjBV,sHACIC,nDACA,AAACV,uEAAMhI,1HAGP,AAACgI,+HAAM,AAACpH,yBAASZ,MACrB2I,oBACAC;;;;;;AA3Hd,CAAA,AAAA,+EAAA,/EAASL,0FA+HCrE,KAAiBqF;;AA/H3B,AAAA,eAAA,XA+HUrF;AA/HV,AAgII,GAAI,AAACpG,wBAAQyL;AACX,OAAQrF,oDAAK,2CAAA,3CAAMqF,gDAAS,2CAAA,3CAAMA;;AAClC,IAAmBC,MAAItF;IAChBuF,KAAG,AAACnH,cAAIiH;;AADf,AAEE,GAAI,OAAA,NAAME;AACRD;;AACA,IAAkBE,IAAE,AAAC1L,gBAAMyL;AAA3B,AACE,GAAI,AAAC3L,wBAAQ4L;AACX,eACE,AAACC,iBAAOH,IAAI,uCAAA,vCAAME,4CAAK,uCAAA,vCAAMA;eAC7B,AAAC1G,eAAKyG;;;;;AACR,MAAO,KAAAtM,MAAA;;;;;;;;AA3IrB,CAAA,AAAA,2EAAA,3EAASoL,sFAWElH;;AAXX,AAAA,YAAA,RAWWA;AAXX,AAYIqC;;;AAZJ,CAAA,0CAAA,1CAAS6E;AAAT,AAAA,AAAA;;;AAAA,CAAA,gDAAA,hDAASA;;AAAT,CAAA,mDAAA,nDAASA;;AAAT,CAAA,wDAAA,WAAAjB,mBAAAC,qBAAAC,3GAASe;AAAT,AAAA,OAAAd,iBAAAF,qBAAA;;;AAAA;;;sCAAA,tCAASiB,oFACM9E,KACZ+E,SACAC,aACAC,aAGAC;AAPH,AAAA,YAAAL,+BACe7E,KACZ+E,SACAC,aACAC,aAGAC;;;AAPML,AA0JZ,6BAAA,7BAAMsB,kEAAYnG;AAAlB,AACE,YAAA6E,+BACE7E,KACA,qBAAA,rBAACyE,wDACD,qBAAA,rBAACA,wDACD,qBAAA,rBAACA,wDACD,yBAAA,zBAAC2B","names",["shadow.grove.db/make-ident","type","id","shadow.grove.db.ident/->Ident","shadow.grove.db/ident?","thing","shadow.grove.db.ident/ident?","js/Error","shadow.grove.db/ident-key","shadow.grove.db/ident-val","shadow.grove.db/ident-as-vec","ident","shadow.grove.db/parse-joins","spec","joins","cljs.core/reduce-kv","attr","val","cljs.core/vector?","cljs.core._EQ_","cljs.core/first","cljs.core.ex_info","cljs.core.update","cljs.core/assoc","cljs.core/second","p__12175","p__12176","map__12177","cljs.core/--destructure-map","cljs.core.get","map__12178","shadow.grove.db/parse-primary-key","entity-type","primary-key","config","and__5043__auto__","cljs.core/not","cljs.core/Keyword","p1__12173#","cljs.core.assoc","cljs.core/every?","cljs.core/keyword?","item","p1__12174#","cljs.core.mapv","p__12183","map__12184","shadow.grove.db/parse-entity-spec","shadow.grove.db/parse-schema","p__12190","map__12191","schema","key","cljs.core/assoc-in","shadow.grove.db/nav-fn","db","cljs.core/coll?","cljs.core.vary_meta","m","shadow.grove.db/configure","init-db","cljs.core/set","cljs.core/keys","cljs.core/with-meta","shadow.grove.db/coll-key","shadow.grove.db/normalize*","imports","map__12195","ident-gen","id-pred","ent-config","cljs.core.get_in","item-ident","_","cljs.core.not_EQ_","join-type","curr-val","norm-val","cljs.core/keyword-identical?","cljs.core/map?","p1__12194#","cljs.core/type","cljs.core.swap_BANG_","cljs.core/conj","shadow.grove.db/normalize","vals","cljs.core/deref","cljs.core.atom","cljs.core/sequential?","seq__12202","cljs.core/seq","chunk__12203","count__12204","i__12205","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/next","shadow.grove.db/set-conj","x","y","cljs.core.conj","shadow.grove.db/merge-or-replace","left","right","cljs.core.merge","shadow.grove.db/merge-imports","data","cljs.core.reduce","p__12222","vec__12223","cljs.core.nth","var_args","G__12235","shadow.grove.db/merge-seq","coll","shadow.grove.db.merge_seq","target-path-or-fn","map__12245","map__12246","cljs.core/meta","entity-spec","idents","cljs.core.map","cljs.core.into","G__12247","cljs.core/fn?","G__12250","shadow.grove.db/add","shadow.grove.db.add","target-path","map__12254","map__12255","G__12256","cljs.core.update_in","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","shadow.grove.db/update-entity","seq12266","G__12267","G__12268","G__12269","G__12270","self__5754__auto__","update-fn","args","p1__12265#","cljs.core.apply","shadow.grove.db/all-idents-of","shadow.grove.db/all-of","p1__12286#","shadow.grove.db/remove","cljs.core.dissoc","shadow.grove.db/remove-idents","shadow$grove$db$IObserved$observed_keys$dyn","x__5393__auto__","m__5394__auto__","shadow.grove.db/observed-keys","goog/typeOf","m__5392__auto__","cljs.core/missing-protocol","shadow.grove.db/IObserved","this","cljs.core/PROTOCOL_SENTINEL","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","shadow.grove.db/ObservedData","shadow.grove.db/->ObservedData","keys-used","cljs.core/persistent!","k","v","cljs.core.conj_BANG_","default","shadow.grove.db/observed","cljs.core/transient","shadow$grove$db$ITxCommit$commit_BANG_$dyn","shadow.grove.db/commit!","shadow.grove.db/ITxCommit","shadow.grove.db/TransactedData","shadow.grove.db/->TransactedData","keys-new","keys-updated","keys-removed","completed-ref","key-is-ident?","next-data","G__12392","cljs.core/disj","next-removed","G__12396","value","prev-val","is-ident-update?","cljs.core/contains?","entry","ret","es","e","cljs.core/-assoc","cljs.core/vreset!","shadow.grove.db/transacted","cljs.core/volatile!"]],"~:used-vars",["^D",["~$cljs.core/--destructure-map","~$cljs.core/PROTOCOL_SENTINEL","~$shadow.grove.db/nav-fn","~$cljs.core/sequential?","~$shadow.grove.db/update-entity","~$cljs.core/keyword?","~$shadow.grove.db/ident-as-vec","~$shadow.grove.db/parse-primary-key","~$shadow.grove.db/commit!","~$cljs.core/vector?","~$cljs.core/=","~$shadow.grove.db/ident-val","~$shadow.grove.db/merge-or-replace","~$cljs.core/keys","~$cljs.core/-assoc","~$cljs.core/-write","~$cljs.core/IndexedSeq","~$shadow.grove.db/remove","~$shadow.grove.db/normalize*","~$cljs.core/count","~$cljs.core/deref","~$shadow.grove.db/parse-schema","~$shadow.grove.db/parse-entity-spec","~$goog/typeOf","~$cljs.core/reduce","~$cljs.core/seq","~$cljs.core/chunk-first","~$cljs.core/apply","~$cljs.core/Keyword","~$cljs.core/vreset!","~$cljs.core/mapv","~$cljs.core/not=","~$cljs.core/dissoc","~$cljs.core/keyword-identical?","~$cljs.core/chunk-rest","~$shadow.grove.db/->TransactedData","~$cljs.core/atom","~$shadow.grove.db/parse-joins","~$shadow.grove.db/merge-imports","~$shadow.grove.db/TransactedData","~$shadow.grove.db/make-ident","~$cljs.core/set","~$shadow.grove.db/all-idents-of","~$shadow.grove.db/coll-key","~$cljs.core/contains?","~$shadow.grove.db.ident/ident?","~$cljs.core/into","~$cljs.core/map?","~$cljs.core/conj","~$cljs.core/-count","~$shadow.grove.db/ITxCommit","~$cljs.core/vary-meta","~$cljs.core/update","~$cljs.core/with-meta","~$cljs.core/map","~$cljs.core/fn?","~$shadow.grove.db/normalize","~$cljs.core/volatile!","~$cljs.core/get-in","~$shadow.grove.db/configure","~$cljs.core/swap!","~$shadow.grove.db/remove-idents","~$shadow.grove.db/->ObservedData","~$cljs.core/get","~$cljs.core/-dissoc","~$shadow.grove.db/ident-key","~$cljs.core/-nth","~$shadow.grove.db/observed-keys","~$shadow.grove.db/all-of","~$shadow.grove.db/ident?","~$shadow.grove.db/ObservedData","~$cljs.core/conj!","~$cljs.core/missing-protocol","~$cljs.core/persistent!","~$cljs.core/-lookup","~$cljs.core/nth","~$cljs.core/ex-info","~$cljs.core/meta","~$cljs.core/second","~$shadow.grove.db/observed","~$shadow.grove.db/merge-seq","~$shadow.grove.db/set-conj","~$cljs.core/next","~$cljs.core/transient","~$cljs.core/not","~$cljs.core/disj","~$cljs.core/assoc","~$cljs.core/assoc-in","~$cljs.core/coll?","~$shadow.grove.db/add","~$cljs.core/reduce-kv","~$cljs.core/-contains-key?","~$cljs.core/first","~$shadow.grove.db.ident/->Ident","~$cljs.core/merge","~$cljs.core/every?","~$cljs.core/update-in","~$shadow.grove.db/transacted","~$js/Error","~$shadow.grove.db/IObserved","~$cljs.core/type","~$cljs.core/chunked-seq?","~$cljs.core/-meta"]]],"~:cache-keys",["~#cmap",[["^14","goog/dom/tagname.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^D",[]],"~:deps-syms",["^Q","~$goog.dom.HtmlElement"]]],["^14","goog/html/trustedtypes.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/labs/useragent/browser.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","~$goog.array","~$goog.object","~$goog.labs.userAgent.util","~$goog.string.internal"]]],["^14","goog/html/safeurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","~$goog.asserts","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^3Y"]]],["^14","goog/array/array.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3Z"]]],["^14","goog/debug/error.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/dom/nodetype.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/string/typedstring.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/object/object.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/dom/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3Z"]]],"~:SHADOW-TIMESTAMP",[1693915017000,1693915017000,1667395541000],["^14","goog/math/long.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3Z","~$goog.reflect"]]],["^14","goog/html/trustedresourceurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3Z","~$goog.fs.blob","^3[","~$goog.html.SafeScript","~$goog.html.trustedtypes","^41","^42","^43","^44"]]],["^14","goog/string/internal.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/functions/functions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/html/safestyle.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^43","~$goog.html.SafeUrl","^44","^3Z","^3Y"]]],["^14","goog/dom/safe.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3Z","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^48","~$goog.html.SafeStyle","^4:","^40","~$goog.html.uncheckedconversions","^43","^3Y"]]],["^14","goog/html/safehtml.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^43","^41","^42","^48","^4>","~$goog.html.SafeStyleSheet","^4:","~$goog.dom.TagName","^40","^44","^3Z","~$goog.labs.userAgent.browser","^3V","^3W","^3Y","~$goog.dom.tags","^49"]]],["^14","goog/dom/tags.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3W"]]],["^14","shadow/grove/db.cljc"],["b8a0dc13df75ac7867d81f2487e68ccce4839bd9","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^P","^N"]]],["^14","goog/fs/blob.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/asserts/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^14","goog/uri/uri.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3V","^3Z","~$goog.collections.maps","~$goog.string","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^14","goog/collections/maps.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/i18n/bidi.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/fs/url.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/base.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",[]]],["^14","goog/structs/structs.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3V","^3W"]]],["^14","shadow/grove/db/ident.cljc"],["b8a0dc13df75ac7867d81f2487e68ccce4839bd9","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^P"]]],["^14","goog/string/string.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","~$goog.dom.safe","^4?","^43","^3Y"]]],["^14","goog/reflect/reflect.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/labs/useragent/util.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","~$goog.labs.userAgent","^3Y"]]],["^14","goog/string/stringbuffer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/labs/useragent/useragent.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","goog/html/uncheckedconversions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3Z","^4=","^48","^4>","^4@","^4:","^40","^43","^3Y","^41"]]],["^14","goog/dom/htmlelement.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q"]]],["^14","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","~$goog.math.Long","~$goog.math.Integer","^4G","^3W","^3V","~$goog.Uri","~$goog.string.StringBuffer"]]],["^14","goog/html/safescript.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^43","^44","^49","^3Z"]]],["^14","goog/html/safestylesheet.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^43","^4>","^44","^3W","^3Z","^3Y"]]],["^14","goog/math/integer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^46"]]],["^14","goog/uri/utils.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3Z","^4G"]]],["^14","goog/string/const.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3Q",["^ ","^3R",null,"^3S",["^D",[]],"^3T",["^Q","^3Z","^44"]]]]],"~:clj-info",["^ ","jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1649406309000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1649406309000,"jar:file:/home/jam/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1649406309000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1649406309000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1649406309000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1649406309000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1667395541000,"jar:file:/home/jam/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1649406309000,"jar:file:/home/jam/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1667395541000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","shadow/grove/db.cljc","^7",1,"^8",5,"^9",1,"^:",20],"^;",["^ ","^<","^=","^>","^?","^@","^A"],"~:shadow/protocol-prefixes",["^D",["shadow$grove$db$IObserved$","shadow$grove$db$ITxCommit$"]],"^B",null,"^C",["^D",["^E","^F"]],"^G","^H","^I",["^ "],"^L",null,"^M",["^ ","^N","^N","^O","^N","^P","^P","^Q","^Q"],"^R",["^D",["^S"]],"~:shadow/js-access-global",["^D",["Error"]],"^T",null,"~:defs",["^ ","~$merge-imports",["^ ","~:protocol-inline",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",236,"^8",8,"^9",236,"^:",21,"~:private",true,"~:arglists",["^W",["~$quote",["^W",[["~$data","~$imports"]]]]]],"^5J",true,"^G","^2:","^6","shadow/grove/db.cljc","^:",21,"~:method-params",["^W",[["^5M","^5N"]]],"~:protocol-impl",null,"~:arglists-meta",["^W",[null,null]],"^8",1,"~:variadic?",false,"^7",236,"~:ret-tag",["^D",[null,"~$any"]],"^9",236,"~:max-fixed-arity",2,"~:fn-var",true,"^5K",["^W",["^5L",["^W",[["^5M","^5N"]]]]]],"~$TransactedData",["^ ","~:num-fields",5,"~:protocols",["^D",["~$cljs.core/ICollection","~$cljs.core/Object","~$cljs.core/ICounted","^2F","~$cljs.core/IMeta","~$cljs.core/IDeref","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^G","^2;","^6","shadow/grove/db.cljc","^:",27,"~:type",true,"^8",13,"^7",639,"~:record",false,"^9",639,"~:tag","~$function","~:skip-protocol-flag",["^D",["^5Z","^60","^61","^62","^63","^64","^65"]]],"~$->TransactedData",["^ ","^5I",null,"^5",["^ ","^5Y",["^D",["^5Z","^5[","^60","^2F","^61","^62","^63","^64","^65"]],"^6","shadow/grove/db.cljc","^:",27,"^8",13,"~:factory","~:positional","^7",639,"^9",639,"^5K",["^W",["^5L",["^W",[["^5M","~$keys-new","~$keys-updated","~$keys-removed","~$completed-ref"]]]]],"^6:",["^D",["^5Z","^60","^61","^62","^63","^64","^65"]],"~:doc","Positional factory function for shadow.grove.db/TransactedData."],"^5Y",["^D",["^5Z","^5[","^60","^2F","^61","^62","^63","^64","^65"]],"^G","^27","^6","shadow/grove/db.cljc","^:",27,"^5O",["^W",[["^5M","^6>","^6?","^6@","^6A"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",4,"^5R",false,"^6<","^6=","^7",639,"^5S","^2;","^9",639,"^5U",5,"^5V",true,"^5K",["^W",["^5L",["^W",[["^5M","^6>","^6?","^6@","^6A"]]]]],"^6:",["^D",["^5Z","^60","^61","^62","^63","^64","^65"]],"^6B","Positional factory function for shadow.grove.db/TransactedData."],"~$add",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",278,"^8",7,"^9",278,"^:",10,"^5K",["^W",["^5L",["^W",[["^5M","~$entity-type","~$item"],["^5M","^6D","^6E","~$target-path"]]]]],"~:top-fn",["^ ","^5R",false,"~:fixed-arity",4,"^5U",4,"^5O",[["^5M","^6D","^6E"],["^5M","^6D","^6E","^6F"]],"^5K",["^W",[["^5M","^6D","^6E"],["^5M","^6D","^6E","^6F"]]],"^5Q",["^W",[null,null]]]],"^G","^3A","^6","shadow/grove/db.cljc","^:",10,"^6G",["^ ","^5R",false,"^6H",4,"^5U",4,"^5O",[["^5M","^6D","^6E"],["^5M","^6D","^6E","^6F"]],"^5K",["^W",[["^5M","^6D","^6E"],["^5M","^6D","^6E","^6F"]]],"^5Q",["^W",[null,null]]],"^5O",[["^5M","^6D","^6E"],["^5M","^6D","^6E","^6F"]],"^5P",null,"^6H",4,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"~:methods",[["^ ","^6H",3,"^5R",false,"^68","^5T"],["^ ","^6H",4,"^5R",false,"^68",["^D",[null,"~$clj","^5T"]]]],"^7",278,"^9",278,"^5U",4,"^5V",true,"^5K",["^W",[["^5M","^6D","^6E"],["^5M","^6D","^6E","^6F"]]]],"~$normalize",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",188,"^8",8,"^9",188,"^:",17,"^5J",true,"^5K",["^W",["^5L",["^W",[["~$schema","^6D","~$vals"]]]]],"^6B","returns a seq of [[ident item] ...] tuples"],"^5J",true,"^G","^2L","^6","shadow/grove/db.cljc","^:",17,"^5O",["^W",[["^6L","^6D","^6M"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",188,"^5S","^5T","^9",188,"^5U",3,"^5V",true,"^5K",["^W",["^5L",["^W",[["^6L","^6D","^6M"]]]]],"^6B","returns a seq of [[ident item] ...] tuples"],"~$transacted",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",793,"^8",7,"^9",793,"^:",17,"^5K",["^W",["^5L",["^W",[["^5M"]]]]]],"^G","^3I","^6","shadow/grove/db.cljc","^:",17,"^5O",["^W",[["^5M"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",793,"^5S","^2;","^9",793,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^5M"]]]]]],"~$make-ident",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",12,"^8",7,"^9",12,"^:",17,"^5K",["^W",["^5L",["^W",[["~$type","~$id"]]]]]],"^G","^2<","^6","shadow/grove/db.cljc","^:",17,"^5O",["^W",[["^6P","^6Q"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",12,"^5S","~$shadow.grove.db.ident/Ident","^9",12,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^6P","^6Q"]]]]]],"~$IObserved",["^ ","^5",["^ ","~:protocol-symbol",true,"^6","shadow/grove/db.cljc","^:",23,"^8",14,"^7",335,"~:protocol-info",["^ ","^6I",["^ ","~$observed-keys",[["~$this"]]]],"^9",335,"~:sigs",["^ ","~:observed-keys",["^ ","^G","^6V","^5K",["^W",[["^6W"]]],"^6B",null]],"~:jsdoc",["^W",["@interface"]]],"^6T",true,"^G","^3K","^6","shadow/grove/db.cljc","^:",23,"^8",1,"^7",335,"^6U",["^ ","^6I",["^ ","^6V",[["^6W"]]]],"~:info",null,"^9",335,"^68","^5T","^6X",["^ ","^6Y",["^ ","^G","^6V","^5K",["^W",[["^6W"]]],"^6B",null]],"~:impls",["^D",["^2Z"]],"^6Z",["^W",["@interface"]]],"~$nav-fn",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",90,"^8",7,"^9",90,"^:",13,"^5K",["^W",["^5L",["^W",[["~$db","~$key","~$val"]]]]]],"^G","^1B","^6","shadow/grove/db.cljc","^:",13,"^5O",["^W",[["^72","^73","^74"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",90,"^5S",["^D",[null,"^6J","^5T","~$cljs.core/MetaFn","~$clj-nil"]],"^9",90,"^5U",3,"^5V",true,"^5K",["^W",["^5L",["^W",[["^72","^73","^74"]]]]]],"^E",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",321,"^8",7,"^9",321,"^:",13,"^5K",["^W",["^5L",["^W",[["^5M","~$thing"]]]]]],"^G","^1Q","^6","shadow/grove/db.cljc","^:",13,"^5O",["^W",[["^5M","^77"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",321,"^5S",["^D",["^6J","^76"]],"^9",321,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^5M","^77"]]]]]],"~$merge-or-replace",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",231,"^8",7,"^9",231,"^:",23,"^5K",["^W",["^5L",["^W",[["~$left","~$right"]]]]]],"^G","^1L","^6","shadow/grove/db.cljc","^:",23,"^5O",["^W",[["^79","^7:"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",231,"^5S",["^D",[null,"^5T","^76"]],"^9",231,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^79","^7:"]]]]]],"~$ident-as-vec",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",29,"^8",7,"^9",29,"^:",19,"^5K",["^W",["^5L",["^W",[["^O"]]]]]],"^G","^1F","^6","shadow/grove/db.cljc","^:",19,"^5O",["^W",[["^O"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",29,"^5S","~$cljs.core/IVector","^9",29,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^O"]]]]]],"~$merge-seq",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",243,"^8",7,"^9",243,"^:",16,"^5K",["^W",["^5L",["^W",[["^5M","^6D","~$coll"],["^5M","^6D","^7>","~$target-path-or-fn"]]]]],"^6G",["^ ","^5R",false,"^6H",4,"^5U",4,"^5O",[["^5M","^6D","^7>"],["^5M","^6D","^7>","^7?"]],"^5K",["^W",[["^5M","^6D","^7>"],["^5M","^6D","^7>","^7?"]]],"^5Q",["^W",[null,null]]]],"^G","^38","^6","shadow/grove/db.cljc","^:",16,"^6G",["^ ","^5R",false,"^6H",4,"^5U",4,"^5O",[["^5M","^6D","^7>"],["^5M","^6D","^7>","^7?"]],"^5K",["^W",[["^5M","^6D","^7>"],["^5M","^6D","^7>","^7?"]]],"^5Q",["^W",[null,null]]],"^5O",[["^5M","^6D","^7>"],["^5M","^6D","^7>","^7?"]],"^5P",null,"^6H",4,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^6I",[["^ ","^6H",3,"^5R",false,"^68","^5T"],["^ ","^6H",4,"^5R",false,"^68",["^D",[null,"^6J","^5T"]]]],"^7",243,"^9",243,"^5U",4,"^5V",true,"^5K",["^W",[["^5M","^6D","^7>"],["^5M","^6D","^7>","^7?"]]]],"~$commit!",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",428,"^8",4,"^9",428,"^:",11,"~:protocol","^2F","^6B",null,"^5K",["^W",["^5L",["^W",[["^6W"]]]]]],"^7A","^2F","^G","^1H","^6","shadow/grove/db.cljc","^:",11,"^5O",["^W",[["^6W"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",427,"^5S","^5T","^9",428,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^6W"]]]]],"^6B",null],"~$set-conj",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",226,"^8",8,"^9",226,"^:",16,"^5J",true,"^5K",["^W",["^5L",["^W",[["~$x","~$y"]]]]]],"^5J",true,"^G","^39","^6","shadow/grove/db.cljc","^:",16,"^5O",["^W",[["~$x","~$y"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",226,"^5S","^6J","^9",226,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["~$x","~$y"]]]]]],"~$normalize*",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",126,"^8",8,"^9",126,"^:",18,"^5J",true,"^5K",["^W",["^5L",["^W",[["^5N","^6L","^6D","^6E"]]]]]],"^5J",true,"^G","^1R","^6","shadow/grove/db.cljc","^:",18,"^5O",["^W",[["^5N","^6L","^6D","^6E"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",126,"^5S","^5T","^9",126,"^5U",4,"^5V",true,"^5K",["^W",["^5L",["^W",[["^5N","^6L","^6D","^6E"]]]]]],"~$parse-schema",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",76,"^8",7,"^9",76,"^:",19,"^5K",["^W",["^5L",["^W",[["~$spec"]]]]]],"^G","^1U","^6","shadow/grove/db.cljc","^:",19,"^5O",["^W",[["^7E"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",76,"^5S",["^D",[null,"^5T"]],"^9",76,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^7E"]]]]]],"~$parse-joins",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",33,"^8",7,"^9",33,"^:",18,"^5K",["^W",["^5L",["^W",[["^7E","~$joins"]]]]]],"^G","^29","^6","shadow/grove/db.cljc","^:",18,"^5O",["^W",[["^7E","^7G"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",33,"^5S",["^D",[null,"^5T"]],"^9",33,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^7E","^7G"]]]]]],"~$ITxCommit",["^ ","^5",["^ ","^6T",true,"^6","shadow/grove/db.cljc","^:",23,"^8",14,"^7",427,"^6U",["^ ","^6I",["^ ","^7@",[["^6W"]]]],"^9",427,"^6X",["^ ","~:commit!",["^ ","^G","^7@","^5K",["^W",[["^6W"]]],"^6B",null]],"^6Z",["^W",["@interface"]]],"^6T",true,"^G","^2F","^6","shadow/grove/db.cljc","^:",23,"^8",1,"^7",427,"^6U",["^ ","^6I",["^ ","^7@",[["^6W"]]]],"^6[",null,"^9",427,"^68","^5T","^6X",["^ ","^7I",["^ ","^G","^7@","^5K",["^W",[["^6W"]]],"^6B",null]],"^70",["^D",["^2;"]],"^6Z",["^W",["@interface"]]],"~$coll-key",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",121,"^8",7,"^9",121,"^:",15,"^5K",["^W",["^5L",["^W",[["^77"]]]]]],"^G","^2?","^6","shadow/grove/db.cljc","^:",15,"^5O",["^W",[["^77"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",121,"^5S","^7<","^9",121,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^77"]]]]]],"~$all-idents-of",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",311,"^8",7,"^9",311,"^:",20,"^5K",["^W",["^5L",["^W",[["^72","^6D"]]]]]],"^G","^2>","^6","shadow/grove/db.cljc","^:",20,"^5O",["^W",[["^72","^6D"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",311,"^5S",["^D",["^5T","^76"]],"^9",311,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^72","^6D"]]]]]],"~$ObservedData",["^ ","^5X",2,"^5Y",["^D",["^61","^63","^3K","^64","^65"]],"^G","^2Z","^6","shadow/grove/db.cljc","^:",25,"^66",true,"^8",13,"^7",387,"^67",false,"^9",387,"^68","^69","^6:",["^D",["^61","^63","^64","^65"]]],"~$all-of",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",315,"^8",7,"^9",315,"^:",13,"^5K",["^W",["^5L",["^W",[["^72","^6D"]]]]]],"^G","^2X","^6","shadow/grove/db.cljc","^:",13,"^5O",["^W",[["^72","^6D"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",315,"^5S","~$cljs.core/LazySeq","^9",315,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^72","^6D"]]]]]],"^F",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",16,"^8",7,"^9",16,"^:",13,"^5K",["^W",["^5L",["^W",[["^77"]]]]]],"^G","^2Y","^6","shadow/grove/db.cljc","^:",13,"^5O",["^W",[["^77"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",16,"^5S","~$boolean","^9",16,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^77"]]]]]],"~$ident-key",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",19,"^8",7,"^9",19,"^:",16,"^5K",["^W",["^5L",["^W",[["^77"]]]]]],"^G","^2U","^6","shadow/grove/db.cljc","^:",16,"^5O",["^W",[["^77"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",19,"^5S","^5T","^9",19,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^77"]]]]]],"~$remove-idents",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",332,"^8",7,"^9",332,"^:",20,"^5K",["^W",["^5L",["^W",[["^5M","~$idents"]]]]]],"^G","^2Q","^6","shadow/grove/db.cljc","^:",20,"^5O",["^W",[["^5M","^7R"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",332,"^5S",["^D",[null,"^5T"]],"^9",332,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^5M","^7R"]]]]]],"~$configure",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",109,"^8",7,"^9",109,"^:",16,"^5K",["^W",["^5L",["^W",[["~$init-db","^7E"]]]]]],"^G","^2O","^6","shadow/grove/db.cljc","^:",16,"^5O",["^W",[["^7T","^7E"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",109,"^5S",["^D",["^6J","^75","^76"]],"^9",109,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^7T","^7E"]]]]]],"~$parse-primary-key",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",46,"^8",7,"^9",46,"^:",24,"^5K",["^W",["^5L",["^W",[[["^ ","~:keys",["^6D"],"^[","^7E"],["^ ","^7V",["~$primary-key"],"^[","~$config"]]]]]]],"^G","^1G","^6","shadow/grove/db.cljc","^:",24,"^5O",["^W",[["~$p__12175","~$p__12176"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",46,"^5S",["^D",[null,"^6J","^5T","^76"]],"^9",46,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[[["^ ","^7V",["^6D"],"^[","^7E"],["^ ","^7V",["^7W"],"^[","^7X"]]]]]]],"~$->ObservedData",["^ ","^5I",null,"^5",["^ ","^5Y",["^D",["^61","^63","^3K","^64","^65"]],"^6","shadow/grove/db.cljc","^:",25,"^8",13,"^6<","^6=","^7",387,"^9",387,"^5K",["^W",["^5L",["^W",[["~$keys-used","^5M"]]]]],"^6:",["^D",["^61","^63","^64","^65"]],"^6B","Positional factory function for shadow.grove.db/ObservedData."],"^5Y",["^D",["^61","^63","^3K","^64","^65"]],"^G","^2R","^6","shadow/grove/db.cljc","^:",25,"^5O",["^W",[["^80","^5M"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",4,"^5R",false,"^6<","^6=","^7",387,"^5S","^2Z","^9",387,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^80","^5M"]]]]],"^6:",["^D",["^61","^63","^64","^65"]],"^6B","Positional factory function for shadow.grove.db/ObservedData."],"^6V",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",336,"^8",4,"^9",336,"^:",17,"^7A","^3K","^6B",null,"^5K",["^W",["^5L",["^W",[["^6W"]]]]]],"^7A","^3K","^G","^2W","^6","shadow/grove/db.cljc","^:",17,"^5O",["^W",[["^6W"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",335,"^5S","^5T","^9",336,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^6W"]]]]],"^6B",null],"~$update-entity",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",307,"^8",7,"^9",307,"^:",20,"^5K",["^W",["^5L",["^W",[["^5M","^6D","^6Q","~$update-fn","~$&","~$args"]]]]],"^6G",["^ ","^5R",true,"^6H",4,"^5U",4,"^5O",[["^W",["^5M","^6D","^6Q","^82","^83"]]],"^5K",["^W",[["^5M","^6D","^6Q","^82","~$&","^83"]]],"^5Q",["^W",[null]]]],"^G","^1D","^6","shadow/grove/db.cljc","^:",20,"^6G",["^ ","^5R",true,"^6H",4,"^5U",4,"^5O",[["^W",["^5M","^6D","^6Q","^82","^83"]]],"^5K",["^W",[["^5M","^6D","^6Q","^82","~$&","^83"]]],"^5Q",["^W",[null]]],"^5O",[["^W",["^5M","^6D","^6Q","^82","^83"]]],"^5P",null,"^6H",4,"^5Q",["^W",[null]],"^8",1,"^5R",true,"^6I",[["^ ","^6H",4,"^5R",true,"^68",["^D",["^6J","^5T"]]]],"^7",307,"^5S","^5T","^9",307,"^5U",4,"^5V",true,"^5K",["^W",[["^5M","^6D","^6Q","^82","~$&","^83"]]]],"~$parse-entity-spec",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",68,"^8",7,"^9",68,"^:",24,"^5K",["^W",["^5L",["^W",[["^6D",["^ ","^7V",["^7G"],"^[","^7X"]]]]]]],"^G","^1V","^6","shadow/grove/db.cljc","^:",24,"^5O",["^W",[["^6D","~$p__12183"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",68,"^5S",["^D",[null,"^5T"]],"^9",68,"^5U",2,"^5V",true,"^5K",["^W",["^5L",["^W",[["^6D",["^ ","^7V",["^7G"],"^[","^7X"]]]]]]],"~$ident-val",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",24,"^8",7,"^9",24,"^:",16,"^5K",["^W",["^5L",["^W",[["^77"]]]]]],"^G","^1K","^6","shadow/grove/db.cljc","^:",16,"^5O",["^W",[["^77"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",24,"^5S","^5T","^9",24,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^77"]]]]]],"~$observed",["^ ","^5I",null,"^5",["^ ","^6","shadow/grove/db.cljc","^7",420,"^8",7,"^9",420,"^:",15,"^5K",["^W",["^5L",["^W",[["^5M"]]]]]],"^G","^37","^6","shadow/grove/db.cljc","^:",15,"^5O",["^W",[["^5M"]]],"^5P",null,"^5Q",["^W",[null,null]],"^8",1,"^5R",false,"^7",420,"^5S","^2Z","^9",420,"^5U",1,"^5V",true,"^5K",["^W",["^5L",["^W",[["^5M"]]]]]]],"^U",["^ ","^P","^P"],"~:cljs.analyzer/constants",["^ ","^R",["^D",["~:id-pred","~:one","~:entity-type","~:v","~:key","~:keys-updated","^5M","~:else","~:config","~:value","~:item","^80","~:shadow.grove.db/schema","~:joins","~:shadow.grove.db/not-found","~:entities","~:val","^6?","^66","~:vals","~:k","~:keys-new","~$not-native","~:thing","~:db/loading","~:keys-removed","~:ident-gen","~:shadow.grove.db/all","~:ident","~:db/ident","^68","^6A","^6>","~:mutable","~$clojure.core.protocols/nav","~:shadow.grove.db/skip","^6@","~:entity","~:many","~:primary-key","~:shadow.grove.db/ident-types","~:data","~$clojure.core.protocols/datafy"]],"~:order",["^8:","^8U","^8C","^8;","^8V","^8M","^8>","^66","^8T","^8E","^8<","^8?","^8Y","^8R","^8B","^8W","^8N","^89","^8P","^8A","^8O","^8S","^8F","^8G","^8K","^8X","^8J","~:k","~:v","^80","^8Q","^5M","^68","^8I","^8H","^8=","^8L","^8@","^8D","^6>","^6?","^6@","^6A"]],"^10",["^ ","^S",["^D",[]]],"^11",["^ "],"^12",["^Q","^P","^N"]],"^K","^H","~:ns-specs",["^ "],"~:ns-spec-vars",["^D",[]],"~:compiler-options",["^3P",[["^91","~:static-fns"],true,["^91","~:shadow-tweaks"],null,["^91","~:source-map-inline"],null,["^91","~:elide-asserts"],false,["^91","~:optimize-constants"],null,["^91","^17"],null,["^91","~:external-config"],null,["^91","~:tooling-config"],null,["^91","~:emit-constants"],null,["^91","~:load-tests"],null,["^91","~:form-size-threshold"],null,["^91","~:global-goog-object&array"],null,["^91","~:data-readers"],null,["^91","~:infer-externs"],"~:auto",["^91","^19"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^91","~:fn-invoke-direct"],null,["^91","~:source-map"],"/dev/null"]]]